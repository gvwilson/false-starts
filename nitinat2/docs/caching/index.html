<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" type="image/x-icon" href="../favicon.ico">
    <title>Nitinat</title>
    <link rel="stylesheet" href="../mccole.css">
    <link rel="stylesheet" href="../tango.css">
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        TeX: { equationNumbers: { autoNumber: "AMS" } }
      })
    </script>
    <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <div class="row">
      <div class="column">
        <h2><a href="../">Nitinat</a></h2>
        <p>
          A model data analysis project
        </p>
	<ol type="1">
  
  <li>
    <a href="../starting/">
      
        Starting
      
    </a>
  </li>
  
  <li>
    <a href="../project/">
      
        Setting Up a Python Project
      
    </a>
  </li>
  
  <li>
    <a href="../dataset/">
      
        Getting a Dataset
      
    </a>
  </li>
  
  <li>
    <a href="../script/">
      
        Writing Robust Scripts
      
    </a>
  </li>
  
  <li>
    <a href="../unittest/">
      
        Unit Testing
      
    </a>
  </li>
  
  <li>
    <a href="../automation/">
      
        Automation
      
    </a>
  </li>
  
  <li>
    <a href="../caching/">
      <strong>
        Caching
      </strong>
    </a>
  </li>
  
  <li>
    <a href="../dependencies/">
      
        Dependencies
      
    </a>
  </li>
  
  <li>
    <a href="../pipeline/">
      
        Building a Pipeline
      
    </a>
  </li>
  
  <li>
    <a href="../configuration/">
      
        Configuration
      
    </a>
  </li>
  
  <li>
    <a href="../provenance/">
      
        Provenance
      
    </a>
  </li>
  
  <li>
    <a href="../organizing/">
      
        Organizing a Data Analysis
      
    </a>
  </li>
  
  <li>
    <a href="../documentation/">
      
        Documentation
      
    </a>
  </li>
  
  <li>
    <a href="../logging/">
      
        Logging
      
    </a>
  </li>
  
  <li>
    <a href="../coverage/">
      
        Code Coverage
      
    </a>
  </li>
  
  <li>
    <a href="../packaging/">
      
        Packaging
      
    </a>
  </li>
  
  <li>
    <a href="../website/">
      
        Build a Website
      
    </a>
  </li>
  
  <li>
    <a href="../indexing/">
      
        Indexing
      
    </a>
  </li>
  
  <li>
    <a href="../approximation/">
      
        Approximation
      
    </a>
  </li>
  
  <li>
    <a href="../database/">
      
        Using a Database
      
    </a>
  </li>
  
  <li>
    <a href="../service/">
      
        Creating a Web Service
      
    </a>
  </li>
  
</ol>
<ol type="A">
  
  <li>
    <a href="../license/">
      
        License
      
    </a>
  </li>
  
  <li>
    <a href="../conduct/">
      
        Code of Conduct
      
    </a>
  </li>
  
  <li>
    <a href="../links/">
      
        Links
      
    </a>
  </li>
  
  <li>
    <a href="../credits/">
      
        Credits
      
    </a>
  </li>
  
</ol>

      </div>
      <div class="column bordered">
        <h1>Caching</h1>
        <ul>
<li>Datasets for real analysis projects are often too large to put in Git</li>
<li>Simulate this by creating two directories in our project<ul>
<li><code>remote</code> holds the "remote" files (which we will actually keep in version control)</li>
<li><code>cache</code> holds the local copies of those files that we do <em>not</em> put in version control</li>
</ul>
</li>
<li>A new file <code>nitinat/cache.py</code> implements a cache for files<ul>
<li>Files are only copied from <code>remote</code> to <code>cache</code> if they're not already in the latter</li>
</ul>
</li>
<li>Add these values to a dictionary <code>CONFIG</code> in <code>nitinat/__init__.py</code><ul>
<li><a class="crossref" href="../configuration/">Chapter 10</a> discusses how to make this configurable</li>
</ul>
</li>
</ul>
<div class="highlight"><span class="filename">nitinat/__init__.py</span><pre><span></span><code><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="n">CONFIG</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;cache&quot;</span><span class="p">:</span> <span class="n">Path</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="s2">&quot;cache&quot;</span><span class="p">),</span>
    <span class="s2">&quot;remote&quot;</span><span class="p">:</span> <span class="n">Path</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="s2">&quot;remote&quot;</span><span class="p">),</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>Then implement the first version of the cache<ul>
<li>Use a <a class="glossref" href="../gloss/#class_method" markdown="1">class method</a>
    rather than a <a class="glossref" href="../gloss/#static_method" markdown="1">static method</a>
because we might want to derive other caching classes from this one,
and we want to be sure we're referring to the right cache if we do</li>
<li>Use an <a class="glossref" href="../gloss/#absolute_path" markdown="1">absolute path</a> for the cached file
    because relative paths will be unreliable once we start configuring directories</li>
</ul>
</li>
</ul>
<div class="highlight"><span class="filename">nitinat/parameters.py</span><pre><span></span><code><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">import</span> <span class="nn">shutil</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">CONFIG</span>


<span class="k">class</span> <span class="nc">FileCache</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Cache large remote files.&quot;&quot;&quot;</span>

    <span class="c1"># Map remote filenames to local cached filenames.</span>
    <span class="n">_cache</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return path to cached copy of file, getting as needed.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_cache</span><span class="p">:</span>
            <span class="n">remote_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">CONFIG</span><span class="p">[</span><span class="s2">&quot;remote&quot;</span><span class="p">],</span> <span class="n">filename</span><span class="p">)</span>
            <span class="n">cache_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">CONFIG</span><span class="p">[</span><span class="s2">&quot;cache&quot;</span><span class="p">],</span> <span class="n">filename</span><span class="p">)</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">copyfile</span><span class="p">(</span><span class="n">remote_path</span><span class="p">,</span> <span class="n">cache_path</span><span class="p">)</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">filename</span><span class="p">]</span> <span class="o">=</span> <span class="n">cache_path</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">filename</span><span class="p">]</span>
</code></pre></div>
<ul>
<li>Move our existing dataset to the <code>remote</code> directory</li>
<li>Test that we can load it by creating <code>tests/test_parameters.py</code> and adding this</li>
</ul>
<div class="highlight"><span class="filename">tests/test_cache.py</span><pre><span></span><code><span class="kn">from</span> <span class="nn">nitinat.cache</span> <span class="kn">import</span> <span class="n">FileCache</span>


<span class="k">def</span> <span class="nf">test_filecache_load_existing_file</span><span class="p">():</span>
    <span class="n">cached</span> <span class="o">=</span> <span class="n">FileCache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;release-count.csv&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">cached</span><span class="o">.</span><span class="n">is_absolute</span><span class="p">()</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">cached</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">reader</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">reader</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;Package,Releases&quot;</span>
</code></pre></div>
<ul>
<li>We should test that the desired file exists and that copying worked</li>
<li>It's OK for <code>shutil.copyfile</code> to throw <code>FileNotFoundError</code> etc.<ul>
<li>Our own exceptions are unlikely to be more informative</li>
</ul>
</li>
<li>But once we start using an actual remote cache,
    we should have something of our own for "can't find what you asked for"</li>
<li>Create <code>nitinat/exceptions.py</code></li>
</ul>
<div class="highlight"><span class="filename">nitinat/exceptions.py</span><pre><span></span><code><span class="sd">&quot;&quot;&quot;Create our own exceptions.&quot;&quot;&quot;</span>

<span class="k">class</span> <span class="nc">NitinatException</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Something went wrong in the Nitinat package.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remember what went wrong.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Printable.&quot;&quot;&quot;</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">msg</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">msg</span> <span class="k">else</span> <span class="s2">&quot;-no message-&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;exc </span><span class="si">{</span><span class="n">msg</span><span class="si">}</span><span class="s2">&gt;&quot;</span>
</code></pre></div>
<ul>
<li>Modify the cache</li>
</ul>
<div class="highlight"><span class="filename">nitinat/cache.py</span><pre><span></span><code>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return path to cached copy of file, getting as needed.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_cache</span><span class="p">:</span>
            <span class="n">remote_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">CONFIG</span><span class="p">[</span><span class="s2">&quot;remote&quot;</span><span class="p">],</span> <span class="n">filename</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">remote_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                <span class="k">raise</span> <span class="n">NitinatException</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No remote file </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">cache_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">CONFIG</span><span class="p">[</span><span class="s2">&quot;cache&quot;</span><span class="p">],</span> <span class="n">filename</span><span class="p">)</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">copyfile</span><span class="p">(</span><span class="n">remote_path</span><span class="p">,</span> <span class="n">cache_path</span><span class="p">)</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">filename</span><span class="p">]</span> <span class="o">=</span> <span class="n">cache_path</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">filename</span><span class="p">]</span>
</code></pre></div>
<ul>
<li>Test that a nonexistent file can't be found</li>
</ul>
<div class="highlight"><span class="filename">tests/test_cache.py</span><pre><span></span><code><span class="kn">import</span> <span class="nn">pytest</span>
<span class="kn">from</span> <span class="nn">nitinat.exceptions</span> <span class="kn">import</span> <span class="n">NitinatException</span>

<span class="k">def</span> <span class="nf">test_filecache_remote_file_doesnt_exist</span><span class="p">():</span>
    <span class="k">with</span> <span class="n">pytest</span><span class="o">.</span><span class="n">raises</span><span class="p">(</span><span class="n">NitinatException</span><span class="p">):</span>
        <span class="n">FileCache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;nonexistent.file&quot;</span><span class="p">)</span>
</code></pre></div>
<ul>
<li>Rely on mocking to test <code>shutil.copyfile</code> failure <em>without</em> actually copying a file</li>
</ul>
<div class="highlight"><span class="filename">tests/test_cache.py</span><pre><span></span><code><span class="k">def</span> <span class="nf">test_filecache_cannot_copy_remote_file</span><span class="p">():</span>
    <span class="k">with</span> <span class="n">patch</span><span class="p">(</span><span class="s2">&quot;nitinat.cache.shutil.copyfile&quot;</span><span class="p">,</span> <span class="n">side_effect</span><span class="o">=</span><span class="ne">FileNotFoundError</span><span class="p">()):</span>
        <span class="k">with</span> <span class="n">pytest</span><span class="o">.</span><span class="n">raises</span><span class="p">(</span><span class="ne">FileNotFoundError</span><span class="p">):</span>
            <span class="n">FileCache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;release-count.csv&quot;</span><span class="p">)</span>
</code></pre></div>
<ul>
<li>Test fails: exception isn't raised</li>
<li>After some head-scratching realize that:<ul>
<li>The test that actually copies a file is running first</li>
<li>So the file is in the cache by the time the second test runs</li>
<li>So the mock of <code>shutil.copyfile</code> isn't called</li>
</ul>
</li>
<li>This is why tests shouldn't have side effects...</li>
<li>Give <code>FileCache</code> a <code>clear</code> method that clears the cache in memory and deletes files on disk</li>
</ul>
<div class="highlight"><span class="filename">nitinat/cache.py</span><pre><span></span><code>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clear the cache, deleting local files.&quot;&quot;&quot;</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">CONFIG</span><span class="p">[</span><span class="s2">&quot;cache&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iterdir</span><span class="p">():</span>
            <span class="n">filename</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>
</code></pre></div>
<ul>
<li>Use a fixture to clear the cache<ul>
<li>Because fixtures can depend on other fixtures,
    but each fixture is only "created" (called) once</li>
</ul>
</li>
</ul>
<div class="highlight"><span class="filename">tests/test_cache.py</span><pre><span></span><code><span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">clear_cache</span><span class="p">():</span>
    <span class="n">FileCache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
</code></pre></div>
<ul>
<li>Rewrite test to include fixture<ul>
<li>Value will be <code>None</code>, since the <code>clear_cache</code> function doesn't return anything</li>
<li>But it guarantees the cache is empty by the time the test function runs</li>
</ul>
</li>
</ul>
<div class="highlight"><span class="filename">tests/test_cache.py</span><pre><span></span><code><span class="k">def</span> <span class="nf">test_filecache_cannot_copy_remote_file</span><span class="p">(</span><span class="n">clear_cache</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">patch</span><span class="p">(</span><span class="s2">&quot;nitinat.cache.shutil.copyfile&quot;</span><span class="p">,</span> <span class="n">side_effect</span><span class="o">=</span><span class="ne">FileNotFoundError</span><span class="p">()):</span>
        <span class="k">with</span> <span class="n">pytest</span><span class="o">.</span><span class="n">raises</span><span class="p">(</span><span class="ne">FileNotFoundError</span><span class="p">):</span>
            <span class="n">FileCache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;release-count.csv&quot;</span><span class="p">)</span>
</code></pre></div>
<ul>
<li>Now test that a given file is only copied once</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">test_filecache_copy_file_once</span><span class="p">(</span><span class="n">clear_cache</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">patch</span><span class="p">(</span><span class="s2">&quot;nitinat.cache.shutil.copyfile&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">mock</span><span class="p">:</span>
        <span class="p">[</span><span class="n">FileCache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;release-count.csv&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
    <span class="k">assert</span> <span class="n">mock</span><span class="o">.</span><span class="n">call_count</span> <span class="o">==</span> <span class="mi">1</span>
</code></pre></div>
<ul>
<li>Mock objects remember how many times they were called</li>
<li>Run this test on its own with <code>pytest -k test_filecache_copy_file_once</code>: it passes</li>
<li>Run the whole test suite: everything else passes too</li>
<li>Add the <code>cache</code> directory to <code>.gitignore</code><ul>
<li>The whole point of this exercise was to avoid caching large files</li>
</ul>
</li>
<li>Really should replace the <code>exists</code> calls as well so that tests don't depend on particular datafiles</li>
<li>And revisit the data download script</li>
</ul>
<div class="callout">
<h3>DVC</h3>
<p>Many tools to manage files that are too large (or too sensitive) to go in Git already exist,
including <a href="https://git-lfs.github.com/">Git LFS</a> and and the newer and more versatile <a href="https://dvc.org/">DVC</a>.
In brief, DVC works as follows:</p>
<ol>
<li>
<p>The user runs <code>dvc init</code> once in a local Git repository to create some configuration files,
    and then <code>dvc remote add -d <em>name</em> <em>url</em></code>
    to tell DVC where large files are actually stored.</p>
</li>
<li>
<p>The command <code>dvc add <em>filename</em></code> adds the specified file to <code>.gitignore</code>
    so that it won't be saved by Git.
    It also creates a small file <code><em>filename</em>.dvc</code> that <em>can</em> be added to Git;
    this file keeps track of which version of the actual file was used.</p>
</li>
<li>
<p><code>dvc push</code> and <code>dvc pull</code> will send large files to remote storage or download them
    based on the IDs stored in the local <code>.dvc</code> files.</p>
</li>
<li>
<p>Any number of repositories can refer to the same large file without any of them storing it
    so long as their DVC remotes point at the same remote storage location.</p>
</li>
</ol>
<p>The extra steps aren't completely invisible to users---people still have to
use <code>dvc pull</code> to get the latest version of a remote large file
before trying to read it with <code>pandas.read_csv</code>, for example---but
it is simple, versatile, and free.</p>
</div>
      </div>
    </div>
  </body>
</html>
