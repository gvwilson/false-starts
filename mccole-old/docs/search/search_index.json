{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"McCole: A Very Simple Publishing System The authors of technical books often use an unholy combination of a static site generator , Pandoc , LaTeX , and some home-brewed scripts to create both web and print versions of their work. McCole is an attempt to create something simpler: it doesn't do nearly as much as any of the tools just mentioned, but it's smaller and less brittle. Setup Make sure you have Python 3.9 or higher. (optional) Install conda and create a conda environment with conda create -n mccole python=3.9 . Clone https://github.com/gvwilson/mccole/ and go into the mccole directory. Install dependencies with pip install -r requirements.txt . Build the test project using python -m mccole -C sample . You can now examine the generated files in sample/_site . Preview the test project using python -m mccole -C sample -r 4000 . You can view the generated files on http://localhost:4000 . Note: these files are not automatically regenerated as you edit them. If you make changes to the package or the source files, you must stop the server with Ctrl-C and restart it. To build and preview a project of your own, use python -m mccole -s /path/to/source -d /path/to/output -r port (filling in the italicized portions). Command-Line Options -C dir / --chdir dir : change working directory before running. All other paths are interpreted relative to this directory. -d dir / --dst dir : specify destination (output) directory. -g file / --config file : specify configuration file. The default is mccole.yml in the current working directory. -k / --keep : keep pre-existing output files. By default McCole deletes the output directory and its contents at startup. -L level / --logging level : set logging level to debug`, info , ``warning , `error , or critical . -r port / --run port : run a server on the specified port after building the site. Use Ctrl-C to stop the server. -s dir / --src dir : specify source (input) directory. -u / --unused : warn about unused items (i.e., unreferenced figures or tables). Configuration File Options The sample configuration file is: author: \"Greg Wilson\" copyrightyear: 2022 repo: https://github.com/gvwilson/mccole title: \"McCole Sample\" tool: McCole src: . dst: _site links: _data/links.yml bib: _data/bibliography.bib gloss: _data/glossary.yml lang: en copy: - \"*/figures/*.svg\" - \"*/figures/*.pdf\" - \"static/*.*\" - \"favicon.ico\" root: index.md chapters: - slug: \"short\" title: \"Short Chapter\" lede: \"Deliberately flawed\" - slug: \"file-backup\" title: \"File Backup\" lede: \"Archiving files with directory structure\" - slug: \"unit-test\" title: \"Unit Testing\" lede: \"Testing software piece by piece\" - slug: \"pattern-matching\" title: \"Pattern Matching\" lede: \"Using patterns to find things in data\" - slug: \"bibliography\" title: \"Bibliography\" appendix: true - slug: \"glossary\" title: \"Glossary\" Its fields are: author [str]: The author name to display in the copyright notice. copyrightyear [int]: The year to display in the copyright notice. repo [url]: Where to find the source of the project. title [str]: The title of the site/book. tool [str]: The name of the tool used to create the site (usually \"McCole\"). src [path]: The source directory relative to the current working directory. dst [path]: The destination directory relative to the current working directory. links [path]: The file containing links to be added to Markdown files (discussed below). bib [path]: The file containing the BibTeX bibliography for the book (discussed below). gloss [path]: The file containing the Glosario glossary for the book (discussed below). lang [str]: An ISO 639-1 language identifier. copy [list of pattern]: A list of filename patterns identifying files to copy verbatim. root [path]: The path to the book's home page (typically \"index.md\"). chapters [list of object]: Descriptions of the chapters and appendices to include: slug [str]: The key identifying the chapter or appendix. McCole process a file called slug /index.md for the chapter or appendix. title [str]: The title of the chapter or appendix. lede [str]: The lede (also called subtitle or tagline) of the chapter or appendix. appendix [optional bool]: true if this is the first appendix, absent otherwise. exclude [optional list of pattern]: A list of filename patterns identifying files that are not copied. The default ignores .git , .DS_Store , and common editor backup files. Syntax McCole uses CommonMark with extensions. (In our defense, everyone adds extensions\u2026) Page Structure, Headings, and References Chapters and appendices should start with YAML front-matter, which must specify the page template in the _template directory. --- template: page.html --- Chapter and appendix files should not have a level-1 heading, table of contents, or list of keywords: these should be included in the mccole.yml configuration file and referenced in the template. Doing this may feel a little unnatural, but ensures that the HTML generated from the Markdown can be inserted into the template as a single long string. Level-2 headings should be written as shown below; please use the chapter slug as the first part of the ID in {#\u2026} . ## Section heading {#short-section} To refer to a chapter, appendix, or section, use: Cross-reference: <a section=\"short-section\"/>. Do not include # in the section attribute's value. Figures and Tables Create figures like this: <figure id=\"short-figure\"> <img src=\"figures/short.svg\" alt=\"Short caption\" /> <figcaption>Long version of short caption.</figcaption> </figure> The id can be used in cross-references (discussed below). Please use the chapter slug as the first part. The src specifies the relative path from the chapter directory to the image file. For consistency, please put figures in a figures sub-directory in each chapter, and please use SVG format. The alt field should contain short alternative text to identify the figure. The figcaption element should contain a longer caption. Do not include numbering: this is added automatically. Create tables like this: <div class=\"table\" id=\"short-table\" cap=\"Short table caption.\"> | Meaning | Selector | | ------- | -------- | | Element with tag `\"elt\"` | `elt` | | Element with `class=\"cls\"` | `.cls` | | Element with `id=\"ident\"` | `#ident` | | `child` element inside a `parent` element | `parent child` | </div> The id can be used in cross-references (discussed below). Please use the chapter slug as the first part. The cap attribute should contain a longer caption. Do not include numbering: this is added automatically. The body of the table is written in Markdown, not HTML. Other References Use Key1,Key2 to create bibliographic citations. (This is an abuse of the cite tag, which is supposed to be used for the titles of works rather than references to them, but McCole cleans this up when generating HTML.) Refer to a figure using <a figure=\"short-figure\"/> (with the figure ID in place of short-figure ). Similarly, refer to a table using <a table=\"short-table\"/> . Use <span g=\"gloss_key\">text</span> to link to a glossary entry, where gloss_key must be a key in the glossary (discussed below). Use <span i=\"index term\">text</span> to indicate text that should appear in the index (discussed below). If a term is both a glossary entry and an index entry, use <span g=\"gloss_key\" i=\"index term\">text</span> . The g attribute must come before the i attribute. Index and glossary indicators must go outside Markdown links, i.e., use <span i=\"index term\">[name][link-key]</span> and not [<span i=\"index term\">name</span>][link-key] . Callouts Use a blockquote with a level-3 heading to create a callout: > ### Callout Title > > This is a paragraph. > > So is this. File Inclusions To include a text-file as a pre-formatted code block, use: <div class=\"include\" file=\"test.py\" /> The file attribute specifies the path to the file to be included relative to the chapter directory. To include only a portion of a file, use: <div class=\"include\" file=\"test.txt\" keep=\"alpha\" /> where alpha identified the section of the file to keep; the file must contain the markers [alpha] and [/alpha] . For example, if the file is: before alpha [alpha] alpha 1 of 2 alpha 2 of 2 [/alpha] after alpha then the displayed text will be: alpha 1 of 2 alpha 2 of 2 If the file is a program, the markers can be placed in comments: print(\"This is omitted\") # [selected] print(\"This is kept\") # [/selected] print(\"This is also omitted\") Note that only one marked section is kept (the first encountered). To omit lines inside a marked section, use: <div class=\"include\" file=\"test.txt\" omit=\"beta\" /> The keep and omit attributes can be combined: McCole will keep the lines indicated by the first attribute, then omit lines within that section indicated by the second attribute. For example, if the input file is: before [beta] beta 1 before gamma [gamma] gamma 1 of 1 [/gamma] beta 2 after gamma [/beta] after then the directive: <div class=\"include\" file=\"test.txt\" keep=\"beta\" omit=\"gamma\" /> will produce: beta 1 before gamma beta 2 after gamma Finally, to include several files at once, use: <div class=\"include\" pat=\"multi.*\" fill=\"py out\" /> The * in the pat attribute is replaced with each fragment of fill in turn to create actual filenames, which are then included. Multi-inclusion cannot be combined with keep or omit . The Bibliography McCole expects a BibTeX bibliography because that's what users are most likely to have already and because there is no open, widely-used alternative based on an easily-parsed format like YAML. The BibTeX-to-HTML generator in mccole/bib.py only handles a subset of BibTeX at the moment. The Glossary The glossary uses the Glosario format. Templates McCole uses the files in _template as page templates. Values are filled in using simple Python string formatting; all of the HTML generated from a Markdown page is copied as one chunk. Links All external links are defined in a YAML file (by default, _data/links.yml ). They are turned into a Markdown link table: [key-1]: url-1 [key-2]: url-2 which is appended to every Markdown file during parsing. Implementation McCole uses: markdown-it-py to parse and render Markdown. bibtexparser to parse BibTeX bibliographies. The processing cycle is: Parse command-line options. Initialize logging and change working directory. Read the configuration file. Command-line options take precedence over configuration file values, which in turn take precedence over default values defined in mccole/config.py . Load the bibliography, glossary, and template files. Collect Markdown files to process based on the root and chapters fields of the configuration file. Turn each Markdown file into a markdown-it token stream. Search those token streams for cross-reference IDs (e.g., figure IDs) and give each a unique sequence number. Delete the output directory unless asked not to. Render the collected files by converting the markdown-it token streams back to HTML and filling in the page's template. As a side-effect, find figure and table IDs that aren't referenced anywhere. Copy non-Markdown files, such as figures and CSS style files. Display warnings and/or errors. Run a preview server if asked to. Colophon McCole (\"muh-COAL\") is named after Robert McCole Wilson (1934-2015), who taught me how to write and that writing well is important. Thanks, Dad.","title":"Home Page"},{"location":"#mccole-a-very-simple-publishing-system","text":"The authors of technical books often use an unholy combination of a static site generator , Pandoc , LaTeX , and some home-brewed scripts to create both web and print versions of their work. McCole is an attempt to create something simpler: it doesn't do nearly as much as any of the tools just mentioned, but it's smaller and less brittle.","title":"McCole: A Very Simple Publishing System"},{"location":"#setup","text":"Make sure you have Python 3.9 or higher. (optional) Install conda and create a conda environment with conda create -n mccole python=3.9 . Clone https://github.com/gvwilson/mccole/ and go into the mccole directory. Install dependencies with pip install -r requirements.txt . Build the test project using python -m mccole -C sample . You can now examine the generated files in sample/_site . Preview the test project using python -m mccole -C sample -r 4000 . You can view the generated files on http://localhost:4000 . Note: these files are not automatically regenerated as you edit them. If you make changes to the package or the source files, you must stop the server with Ctrl-C and restart it. To build and preview a project of your own, use python -m mccole -s /path/to/source -d /path/to/output -r port (filling in the italicized portions).","title":"Setup"},{"location":"#command-line-options","text":"-C dir / --chdir dir : change working directory before running. All other paths are interpreted relative to this directory. -d dir / --dst dir : specify destination (output) directory. -g file / --config file : specify configuration file. The default is mccole.yml in the current working directory. -k / --keep : keep pre-existing output files. By default McCole deletes the output directory and its contents at startup. -L level / --logging level : set logging level to debug`, info , ``warning , `error , or critical . -r port / --run port : run a server on the specified port after building the site. Use Ctrl-C to stop the server. -s dir / --src dir : specify source (input) directory. -u / --unused : warn about unused items (i.e., unreferenced figures or tables).","title":"Command-Line Options"},{"location":"#configuration-file-options","text":"The sample configuration file is: author: \"Greg Wilson\" copyrightyear: 2022 repo: https://github.com/gvwilson/mccole title: \"McCole Sample\" tool: McCole src: . dst: _site links: _data/links.yml bib: _data/bibliography.bib gloss: _data/glossary.yml lang: en copy: - \"*/figures/*.svg\" - \"*/figures/*.pdf\" - \"static/*.*\" - \"favicon.ico\" root: index.md chapters: - slug: \"short\" title: \"Short Chapter\" lede: \"Deliberately flawed\" - slug: \"file-backup\" title: \"File Backup\" lede: \"Archiving files with directory structure\" - slug: \"unit-test\" title: \"Unit Testing\" lede: \"Testing software piece by piece\" - slug: \"pattern-matching\" title: \"Pattern Matching\" lede: \"Using patterns to find things in data\" - slug: \"bibliography\" title: \"Bibliography\" appendix: true - slug: \"glossary\" title: \"Glossary\" Its fields are: author [str]: The author name to display in the copyright notice. copyrightyear [int]: The year to display in the copyright notice. repo [url]: Where to find the source of the project. title [str]: The title of the site/book. tool [str]: The name of the tool used to create the site (usually \"McCole\"). src [path]: The source directory relative to the current working directory. dst [path]: The destination directory relative to the current working directory. links [path]: The file containing links to be added to Markdown files (discussed below). bib [path]: The file containing the BibTeX bibliography for the book (discussed below). gloss [path]: The file containing the Glosario glossary for the book (discussed below). lang [str]: An ISO 639-1 language identifier. copy [list of pattern]: A list of filename patterns identifying files to copy verbatim. root [path]: The path to the book's home page (typically \"index.md\"). chapters [list of object]: Descriptions of the chapters and appendices to include: slug [str]: The key identifying the chapter or appendix. McCole process a file called slug /index.md for the chapter or appendix. title [str]: The title of the chapter or appendix. lede [str]: The lede (also called subtitle or tagline) of the chapter or appendix. appendix [optional bool]: true if this is the first appendix, absent otherwise. exclude [optional list of pattern]: A list of filename patterns identifying files that are not copied. The default ignores .git , .DS_Store , and common editor backup files.","title":"Configuration File Options"},{"location":"#syntax","text":"McCole uses CommonMark with extensions. (In our defense, everyone adds extensions\u2026)","title":"Syntax"},{"location":"#page-structure-headings-and-references","text":"Chapters and appendices should start with YAML front-matter, which must specify the page template in the _template directory. --- template: page.html --- Chapter and appendix files should not have a level-1 heading, table of contents, or list of keywords: these should be included in the mccole.yml configuration file and referenced in the template. Doing this may feel a little unnatural, but ensures that the HTML generated from the Markdown can be inserted into the template as a single long string. Level-2 headings should be written as shown below; please use the chapter slug as the first part of the ID in {#\u2026} . ## Section heading {#short-section} To refer to a chapter, appendix, or section, use: Cross-reference: <a section=\"short-section\"/>. Do not include # in the section attribute's value.","title":"Page Structure, Headings, and References"},{"location":"#figures-and-tables","text":"Create figures like this: <figure id=\"short-figure\"> <img src=\"figures/short.svg\" alt=\"Short caption\" /> <figcaption>Long version of short caption.</figcaption> </figure> The id can be used in cross-references (discussed below). Please use the chapter slug as the first part. The src specifies the relative path from the chapter directory to the image file. For consistency, please put figures in a figures sub-directory in each chapter, and please use SVG format. The alt field should contain short alternative text to identify the figure. The figcaption element should contain a longer caption. Do not include numbering: this is added automatically. Create tables like this: <div class=\"table\" id=\"short-table\" cap=\"Short table caption.\"> | Meaning | Selector | | ------- | -------- | | Element with tag `\"elt\"` | `elt` | | Element with `class=\"cls\"` | `.cls` | | Element with `id=\"ident\"` | `#ident` | | `child` element inside a `parent` element | `parent child` | </div> The id can be used in cross-references (discussed below). Please use the chapter slug as the first part. The cap attribute should contain a longer caption. Do not include numbering: this is added automatically. The body of the table is written in Markdown, not HTML.","title":"Figures and Tables"},{"location":"#other-references","text":"Use Key1,Key2 to create bibliographic citations. (This is an abuse of the cite tag, which is supposed to be used for the titles of works rather than references to them, but McCole cleans this up when generating HTML.) Refer to a figure using <a figure=\"short-figure\"/> (with the figure ID in place of short-figure ). Similarly, refer to a table using <a table=\"short-table\"/> . Use <span g=\"gloss_key\">text</span> to link to a glossary entry, where gloss_key must be a key in the glossary (discussed below). Use <span i=\"index term\">text</span> to indicate text that should appear in the index (discussed below). If a term is both a glossary entry and an index entry, use <span g=\"gloss_key\" i=\"index term\">text</span> . The g attribute must come before the i attribute. Index and glossary indicators must go outside Markdown links, i.e., use <span i=\"index term\">[name][link-key]</span> and not [<span i=\"index term\">name</span>][link-key] .","title":"Other References"},{"location":"#callouts","text":"Use a blockquote with a level-3 heading to create a callout: > ### Callout Title > > This is a paragraph. > > So is this.","title":"Callouts"},{"location":"#file-inclusions","text":"To include a text-file as a pre-formatted code block, use: <div class=\"include\" file=\"test.py\" /> The file attribute specifies the path to the file to be included relative to the chapter directory. To include only a portion of a file, use: <div class=\"include\" file=\"test.txt\" keep=\"alpha\" /> where alpha identified the section of the file to keep; the file must contain the markers [alpha] and [/alpha] . For example, if the file is: before alpha [alpha] alpha 1 of 2 alpha 2 of 2 [/alpha] after alpha then the displayed text will be: alpha 1 of 2 alpha 2 of 2 If the file is a program, the markers can be placed in comments: print(\"This is omitted\") # [selected] print(\"This is kept\") # [/selected] print(\"This is also omitted\") Note that only one marked section is kept (the first encountered). To omit lines inside a marked section, use: <div class=\"include\" file=\"test.txt\" omit=\"beta\" /> The keep and omit attributes can be combined: McCole will keep the lines indicated by the first attribute, then omit lines within that section indicated by the second attribute. For example, if the input file is: before [beta] beta 1 before gamma [gamma] gamma 1 of 1 [/gamma] beta 2 after gamma [/beta] after then the directive: <div class=\"include\" file=\"test.txt\" keep=\"beta\" omit=\"gamma\" /> will produce: beta 1 before gamma beta 2 after gamma Finally, to include several files at once, use: <div class=\"include\" pat=\"multi.*\" fill=\"py out\" /> The * in the pat attribute is replaced with each fragment of fill in turn to create actual filenames, which are then included. Multi-inclusion cannot be combined with keep or omit .","title":"File Inclusions"},{"location":"#the-bibliography","text":"McCole expects a BibTeX bibliography because that's what users are most likely to have already and because there is no open, widely-used alternative based on an easily-parsed format like YAML. The BibTeX-to-HTML generator in mccole/bib.py only handles a subset of BibTeX at the moment.","title":"The Bibliography"},{"location":"#the-glossary","text":"The glossary uses the Glosario format.","title":"The Glossary"},{"location":"#templates","text":"McCole uses the files in _template as page templates. Values are filled in using simple Python string formatting; all of the HTML generated from a Markdown page is copied as one chunk.","title":"Templates"},{"location":"#links","text":"All external links are defined in a YAML file (by default, _data/links.yml ). They are turned into a Markdown link table: [key-1]: url-1 [key-2]: url-2 which is appended to every Markdown file during parsing.","title":"Links"},{"location":"#implementation","text":"McCole uses: markdown-it-py to parse and render Markdown. bibtexparser to parse BibTeX bibliographies. The processing cycle is: Parse command-line options. Initialize logging and change working directory. Read the configuration file. Command-line options take precedence over configuration file values, which in turn take precedence over default values defined in mccole/config.py . Load the bibliography, glossary, and template files. Collect Markdown files to process based on the root and chapters fields of the configuration file. Turn each Markdown file into a markdown-it token stream. Search those token streams for cross-reference IDs (e.g., figure IDs) and give each a unique sequence number. Delete the output directory unless asked not to. Render the collected files by converting the markdown-it token streams back to HTML and filling in the page's template. As a side-effect, find figure and table IDs that aren't referenced anywhere. Copy non-Markdown files, such as figures and CSS style files. Display warnings and/or errors. Run a preview server if asked to.","title":"Implementation"},{"location":"#colophon","text":"McCole (\"muh-COAL\") is named after Robert McCole Wilson (1934-2015), who taught me how to write and that writing well is important. Thanks, Dad.","title":"Colophon"},{"location":"accounting/","text":"Accounting Keep track of information. Config dataclass Config(author: str = '', bib: str = '', bib_data: list = , bib_keys: set = , builddate: str = '', chapters: list = , copy: list = , copyrightyear: str = '', domain: str = '', dst: str = '', email: str = '', exclude: list = , gloss: str = '', gloss_data: list = , gloss_keys: set = , lang: str = '', links: str = '', links_data: dict = , pages: list = , repo: str = '', root: str = '', src: str = '', subtitle: str = '', template: dict = , terms: dict = , title: str = '', tool: str = '') Source code in mccole/accounting.py @dataclass class Config : author : str = \"\" bib : str = \"\" bib_data : list = field ( default_factory = list ) bib_keys : set = field ( default_factory = set ) builddate : str = \"\" chapters : list = field ( default_factory = list ) copy : list = field ( default_factory = list ) copyrightyear : str = \"\" domain : str = \"\" dst : str = \"\" email : str = \"\" exclude : list = field ( default_factory = list ) gloss : str = \"\" gloss_data : list = field ( default_factory = list ) gloss_keys : set = field ( default_factory = set ) lang : str = \"\" links : str = \"\" links_data : dict = field ( default_factory = dict ) pages : list = field ( default_factory = list ) repo : str = \"\" root : str = \"\" src : str = \"\" subtitle : str = \"\" template : dict = field ( default_factory = dict ) terms : dict = field ( default_factory = lambda : { \"en\" : { \"appendix\" : \"Appendix\" , \"chapter\" : \"Chapter\" , \"figure\" : \"Figure\" , \"section\" : \"Section\" , \"table\" : \"Table\" }, \"es\" : { \"appendix\" : \"Anexo\" , \"chapter\" : \"Cap\u00edtulo\" , \"figure\" : \"Figura\" , \"section\" : \"Secc\u00edon\" , \"table\" : \"Tabla\" } }) title : str = \"\" tool : str = \"\" CrossRef dataclass CrossRef(fig_id_to_index: dict = , fig_id_to_slug: dict = , hd_id_to_index: dict = , hd_id_to_slug: dict = , hd_id_to_title: dict = , hd_index_to_id: dict = , tbl_id_to_index: dict = , tbl_id_to_slug: dict = ) Source code in mccole/accounting.py @dataclass class CrossRef : # embedded figure ID (str) to multi-part label (tuple) fig_id_to_index : dict = field ( default_factory = dict ) # embedded figure ID (str) to chapter slug (str) fig_id_to_slug : dict = field ( default_factory = dict ) # embedded heading ID (str) to multi-part label (tuple) hd_id_to_index : dict = field ( default_factory = dict ) # embedded heading ID (str) to chapter slug (str) hd_id_to_slug : dict = field ( default_factory = dict ) # embedded heading ID (str) to chapter title (str) hd_id_to_title : dict = field ( default_factory = dict ) # multi-part heading label (tuple) to embedded heading ID (str) hd_index_to_id : dict = field ( default_factory = dict ) # embedded table ID (str) to multi-part label (tuple) tbl_id_to_index : dict = field ( default_factory = dict ) # embedded table ID (str) to chapter slug (str) tbl_id_to_slug : dict = field ( default_factory = dict ) Info dataclass Information about a single page. Source code in mccole/accounting.py @dataclass class Info : \"\"\"Information about a single page.\"\"\" dst : str = \"\" lede : str = \"\" major : str = \"\" metadata : dict = field ( default_factory = dict ) slug : str = \"\" src : str = \"\" template : str = \"\" title : str = \"\" to_root : str = \"\" tokens : list = field ( default_factory = list ) Seen dataclass What cross-references have been seen? Source code in mccole/accounting.py @dataclass class Seen : \"\"\"What cross-references have been seen?\"\"\" cite : set = field ( default_factory = set ) figure_ref : set = field ( default_factory = set ) gloss_ref : set = field ( default_factory = set ) index_ref : set = field ( default_factory = set ) table_ref : set = field ( default_factory = set )","title":"Accounting"},{"location":"accounting/#accounting","text":"Keep track of information.","title":"Accounting"},{"location":"accounting/#mccole.accounting.Config","text":"Config(author: str = '', bib: str = '', bib_data: list = , bib_keys: set = , builddate: str = '', chapters: list = , copy: list = , copyrightyear: str = '', domain: str = '', dst: str = '', email: str = '', exclude: list = , gloss: str = '', gloss_data: list = , gloss_keys: set = , lang: str = '', links: str = '', links_data: dict = , pages: list = , repo: str = '', root: str = '', src: str = '', subtitle: str = '', template: dict = , terms: dict = , title: str = '', tool: str = '') Source code in mccole/accounting.py @dataclass class Config : author : str = \"\" bib : str = \"\" bib_data : list = field ( default_factory = list ) bib_keys : set = field ( default_factory = set ) builddate : str = \"\" chapters : list = field ( default_factory = list ) copy : list = field ( default_factory = list ) copyrightyear : str = \"\" domain : str = \"\" dst : str = \"\" email : str = \"\" exclude : list = field ( default_factory = list ) gloss : str = \"\" gloss_data : list = field ( default_factory = list ) gloss_keys : set = field ( default_factory = set ) lang : str = \"\" links : str = \"\" links_data : dict = field ( default_factory = dict ) pages : list = field ( default_factory = list ) repo : str = \"\" root : str = \"\" src : str = \"\" subtitle : str = \"\" template : dict = field ( default_factory = dict ) terms : dict = field ( default_factory = lambda : { \"en\" : { \"appendix\" : \"Appendix\" , \"chapter\" : \"Chapter\" , \"figure\" : \"Figure\" , \"section\" : \"Section\" , \"table\" : \"Table\" }, \"es\" : { \"appendix\" : \"Anexo\" , \"chapter\" : \"Cap\u00edtulo\" , \"figure\" : \"Figura\" , \"section\" : \"Secc\u00edon\" , \"table\" : \"Tabla\" } }) title : str = \"\" tool : str = \"\"","title":"Config"},{"location":"accounting/#mccole.accounting.CrossRef","text":"CrossRef(fig_id_to_index: dict = , fig_id_to_slug: dict = , hd_id_to_index: dict = , hd_id_to_slug: dict = , hd_id_to_title: dict = , hd_index_to_id: dict = , tbl_id_to_index: dict = , tbl_id_to_slug: dict = ) Source code in mccole/accounting.py @dataclass class CrossRef : # embedded figure ID (str) to multi-part label (tuple) fig_id_to_index : dict = field ( default_factory = dict ) # embedded figure ID (str) to chapter slug (str) fig_id_to_slug : dict = field ( default_factory = dict ) # embedded heading ID (str) to multi-part label (tuple) hd_id_to_index : dict = field ( default_factory = dict ) # embedded heading ID (str) to chapter slug (str) hd_id_to_slug : dict = field ( default_factory = dict ) # embedded heading ID (str) to chapter title (str) hd_id_to_title : dict = field ( default_factory = dict ) # multi-part heading label (tuple) to embedded heading ID (str) hd_index_to_id : dict = field ( default_factory = dict ) # embedded table ID (str) to multi-part label (tuple) tbl_id_to_index : dict = field ( default_factory = dict ) # embedded table ID (str) to chapter slug (str) tbl_id_to_slug : dict = field ( default_factory = dict )","title":"CrossRef"},{"location":"accounting/#mccole.accounting.Info","text":"Information about a single page. Source code in mccole/accounting.py @dataclass class Info : \"\"\"Information about a single page.\"\"\" dst : str = \"\" lede : str = \"\" major : str = \"\" metadata : dict = field ( default_factory = dict ) slug : str = \"\" src : str = \"\" template : str = \"\" title : str = \"\" to_root : str = \"\" tokens : list = field ( default_factory = list )","title":"Info"},{"location":"accounting/#mccole.accounting.Seen","text":"What cross-references have been seen? Source code in mccole/accounting.py @dataclass class Seen : \"\"\"What cross-references have been seen?\"\"\" cite : set = field ( default_factory = set ) figure_ref : set = field ( default_factory = set ) gloss_ref : set = field ( default_factory = set ) index_ref : set = field ( default_factory = set ) table_ref : set = field ( default_factory = set )","title":"Seen"},{"location":"bib/","text":"Bibliography Handle bibliography. bib_to_html ( config ) Create HTML version of bibliography data. Source code in mccole/bib.py def bib_to_html ( config ): \"\"\"Create HTML version of bibliography data.\"\"\" entries = [ _bib_to_html ( e ) for e in config . bib_data ] return \" \\n \" . join ([ '<div class=\"bibliography\">' , \" \\n \" . join ( entries ), \"</div>\" ]) load_bib ( config ) Read bibliography file if there is one. Source code in mccole/bib.py def load_bib ( config ): \"\"\"Read bibliography file if there is one.\"\"\" if not config . bib : return try : with open ( config . bib , \"r\" ) as reader : config . bib_data = bibtexparser . load ( reader ) . entries except OSError : raise McColeExc ( f \"Unable to open bibliography file { config . bib } .\" ) config . bib_keys = { entry [ \"ID\" ] for entry in config . bib_data }","title":"Bibliography"},{"location":"bib/#bibliography","text":"Handle bibliography.","title":"Bibliography"},{"location":"bib/#mccole.bib.bib_to_html","text":"Create HTML version of bibliography data. Source code in mccole/bib.py def bib_to_html ( config ): \"\"\"Create HTML version of bibliography data.\"\"\" entries = [ _bib_to_html ( e ) for e in config . bib_data ] return \" \\n \" . join ([ '<div class=\"bibliography\">' , \" \\n \" . join ( entries ), \"</div>\" ])","title":"bib_to_html()"},{"location":"bib/#mccole.bib.load_bib","text":"Read bibliography file if there is one. Source code in mccole/bib.py def load_bib ( config ): \"\"\"Read bibliography file if there is one.\"\"\" if not config . bib : return try : with open ( config . bib , \"r\" ) as reader : config . bib_data = bibtexparser . load ( reader ) . entries except OSError : raise McColeExc ( f \"Unable to open bibliography file { config . bib } .\" ) config . bib_keys = { entry [ \"ID\" ] for entry in config . bib_data }","title":"load_bib()"},{"location":"check/","text":"Checks Check consistency of project. check ( options , config , xref , seen ) Check various aspects of project. Source code in mccole/check.py def check ( options , config , xref , seen ): \"\"\"Check various aspects of project.\"\"\" if \"bib\" in options . check : _check_bib ( config , seen ) if \"code\" in options . check : _check_code ( config ) if \"gloss\" in options . check : _check_gloss ( config , seen )","title":"Checks"},{"location":"check/#checks","text":"Check consistency of project.","title":"Checks"},{"location":"check/#mccole.check.check","text":"Check various aspects of project. Source code in mccole/check.py def check ( options , config , xref , seen ): \"\"\"Check various aspects of project.\"\"\" if \"bib\" in options . check : _check_bib ( config , seen ) if \"code\" in options . check : _check_code ( config ) if \"gloss\" in options . check : _check_gloss ( config , seen )","title":"check()"},{"location":"collect/","text":"Collect Collect pages to be transformed. collect_pages ( config ) Return page information. Source code in mccole/collect.py def collect_pages ( config ): \"\"\"Return page information.\"\"\" if not config . chapters : return [] major = 0 result = [] for entry in config . chapters : major = _next_major ( entry , major ) try : result . append ( Info ( slug = entry [ \"slug\" ], to_root = os . pardir , src = _src_path ( config , entry ), dst = _dst_path ( config , entry ), lede = entry . get ( \"lede\" , \"\" ), major = major , metadata = {}, title = entry [ \"title\" ], template = entry . get ( \"template\" , None ), tokens = None , ) ) except KeyError as exc : raise McColeExc ( f \"Missing entry { exc } in configuration for { entry } .\" ) if config . root : result . append ( Info ( slug = \"_index\" , to_root = os . curdir , src = os . path . join ( config . src , config . root ), dst = os . path . join ( config . dst , \"index.html\" ), major = None , metadata = {}, template = entry . get ( \"template\" , None ), tokens = None , ) ) config . pages = result","title":"File Collection"},{"location":"collect/#collect","text":"Collect pages to be transformed.","title":"Collect"},{"location":"collect/#mccole.collect.collect_pages","text":"Return page information. Source code in mccole/collect.py def collect_pages ( config ): \"\"\"Return page information.\"\"\" if not config . chapters : return [] major = 0 result = [] for entry in config . chapters : major = _next_major ( entry , major ) try : result . append ( Info ( slug = entry [ \"slug\" ], to_root = os . pardir , src = _src_path ( config , entry ), dst = _dst_path ( config , entry ), lede = entry . get ( \"lede\" , \"\" ), major = major , metadata = {}, title = entry [ \"title\" ], template = entry . get ( \"template\" , None ), tokens = None , ) ) except KeyError as exc : raise McColeExc ( f \"Missing entry { exc } in configuration for { entry } .\" ) if config . root : result . append ( Info ( slug = \"_index\" , to_root = os . curdir , src = os . path . join ( config . src , config . root ), dst = os . path . join ( config . dst , \"index.html\" ), major = None , metadata = {}, template = entry . get ( \"template\" , None ), tokens = None , ) ) config . pages = result","title":"collect_pages()"},{"location":"conduct/","text":"Contributor Covenant Code of Conduct Our Pledge We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation. We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community. Our Standards Examples of behavior that contributes to a positive environment for our community include: Demonstrating empathy and kindness toward other people Being respectful of differing opinions, viewpoints, and experiences Giving and gracefully accepting constructive feedback Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience Focusing on what is best not just for us as individuals, but for the overall community Examples of unacceptable behavior include: The use of sexualized language or imagery, and sexual attention or advances of any kind Trolling, insulting or derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or email address, without their explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Enforcement Responsibilities Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful. Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate. Scope This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at gvwilson@third-bit.com. All complaints will be reviewed and investigated promptly and fairly. All community leaders are obligated to respect the privacy and security of the reporter of any incident. Enforcement Guidelines Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct: 1. Correction Community Impact : Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community. Consequence : A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested. 2. Warning Community Impact : A violation through a single incident or series of actions. Consequence : A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban. 3. Temporary Ban Community Impact : A serious violation of community standards, including sustained inappropriate behavior. Consequence : A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban. 4. Permanent Ban Community Impact : Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals. Consequence : A permanent ban from any sort of public interaction within the community. Attribution This Code of Conduct is adapted from the Contributor Covenant] homepage , version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html . Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder . For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq . Translations are available at https://www.contributor-covenant.org/translations .","title":"Code of Conduct"},{"location":"conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"conduct/#our-pledge","text":"We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation. We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.","title":"Our Pledge"},{"location":"conduct/#our-standards","text":"Examples of behavior that contributes to a positive environment for our community include: Demonstrating empathy and kindness toward other people Being respectful of differing opinions, viewpoints, and experiences Giving and gracefully accepting constructive feedback Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience Focusing on what is best not just for us as individuals, but for the overall community Examples of unacceptable behavior include: The use of sexualized language or imagery, and sexual attention or advances of any kind Trolling, insulting or derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or email address, without their explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"conduct/#enforcement-responsibilities","text":"Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful. Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.","title":"Enforcement Responsibilities"},{"location":"conduct/#scope","text":"This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.","title":"Scope"},{"location":"conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at gvwilson@third-bit.com. All complaints will be reviewed and investigated promptly and fairly. All community leaders are obligated to respect the privacy and security of the reporter of any incident.","title":"Enforcement"},{"location":"conduct/#enforcement-guidelines","text":"Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:","title":"Enforcement Guidelines"},{"location":"conduct/#1-correction","text":"Community Impact : Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community. Consequence : A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.","title":"1. Correction"},{"location":"conduct/#2-warning","text":"Community Impact : A violation through a single incident or series of actions. Consequence : A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.","title":"2. Warning"},{"location":"conduct/#3-temporary-ban","text":"Community Impact : A serious violation of community standards, including sustained inappropriate behavior. Consequence : A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.","title":"3. Temporary Ban"},{"location":"conduct/#4-permanent-ban","text":"Community Impact : Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals. Consequence : A permanent ban from any sort of public interaction within the community.","title":"4. Permanent Ban"},{"location":"conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant] homepage , version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html . Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder . For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq . Translations are available at https://www.contributor-covenant.org/translations .","title":"Attribution"},{"location":"config/","text":"Configuration Manage program configuration. load_config ( options ) Read configuration file. Source code in mccole/config.py def load_config ( options ): \"\"\"Read configuration file.\"\"\" try : with open ( options . config , \"r\" ) as reader : config = yaml . safe_load ( reader ) or {} config = DEFAULTS | config config = Config ( ** config ) if hasattr ( options , \"src\" ): config . src = options . src if hasattr ( options , \"dst\" ): config . dst = options . dst if config . links : config . links_data = _read_links ( config . links ) load_templates ( config ) return config except OSError as exc : raise McColeExc ( str ( exc ))","title":"Configuration"},{"location":"config/#configuration","text":"Manage program configuration.","title":"Configuration"},{"location":"config/#mccole.config.load_config","text":"Read configuration file. Source code in mccole/config.py def load_config ( options ): \"\"\"Read configuration file.\"\"\" try : with open ( options . config , \"r\" ) as reader : config = yaml . safe_load ( reader ) or {} config = DEFAULTS | config config = Config ( ** config ) if hasattr ( options , \"src\" ): config . src = options . src if hasattr ( options , \"dst\" ): config . dst = options . dst if config . links : config . links_data = _read_links ( config . links ) load_templates ( config ) return config except OSError as exc : raise McColeExc ( str ( exc ))","title":"load_config()"},{"location":"crossref/","text":"Cross References Create cross-reference lookup. cross_reference ( config ) Create cross-reference tables for all pages. Source code in mccole/crossref.py def cross_reference ( config ): \"\"\"Create cross-reference tables for all pages.\"\"\" # Exclude un-indexed pages (e.g., home page). pages = [ p for p in config . pages if p . major is not None ] xref = CrossRef () _headings ( config , xref , pages ) _figures ( config , xref , pages ) _tables ( config , xref , pages ) return xref","title":"Cross References"},{"location":"crossref/#cross-references","text":"Create cross-reference lookup.","title":"Cross References"},{"location":"crossref/#mccole.crossref.cross_reference","text":"Create cross-reference tables for all pages. Source code in mccole/crossref.py def cross_reference ( config ): \"\"\"Create cross-reference tables for all pages.\"\"\" # Exclude un-indexed pages (e.g., home page). pages = [ p for p in config . pages if p . major is not None ] xref = CrossRef () _headings ( config , xref , pages ) _figures ( config , xref , pages ) _tables ( config , xref , pages ) return xref","title":"cross_reference()"},{"location":"gloss/","text":"Glossary Generate a glossary. gloss_to_html ( config , seen ) Convert glossary data to HTML. Source code in mccole/gloss.py def gloss_to_html ( config , seen ): \"\"\"Convert glossary data to HTML.\"\"\" if not config . lang : raise McColeExc ( \"Cannot convert glossary: no language in configuration.\" ) try : internal = { entry [ \"key\" ]: entry [ config . lang ][ \"term\" ] for entry in config . gloss_data } except KeyError as exc : raise McColeExc ( f \"Glossary entry or entries missing 'key' { exc } .\" ) entries = [ _gloss_to_markdown ( entry , config . lang , internal , seen ) for entry in config . gloss_data ] text = \" \\n\\n \" . join ( entries ) md = make_md () html = md . render ( text ) return html load_gloss ( config ) Read glossary file if there is one. Source code in mccole/gloss.py def load_gloss ( config ): \"\"\"Read glossary file if there is one.\"\"\" if not config . gloss : return try : with open ( config . gloss , \"r\" ) as reader : config . gloss_data = yaml . safe_load ( reader ) or [] except OSError : raise McColeExc ( f \"Unable to open glossary file { config . gloss } .\" ) config . gloss_keys = { entry [ \"key\" ] for entry in config . gloss_data }","title":"Glossary"},{"location":"gloss/#glossary","text":"Generate a glossary.","title":"Glossary"},{"location":"gloss/#mccole.gloss.gloss_to_html","text":"Convert glossary data to HTML. Source code in mccole/gloss.py def gloss_to_html ( config , seen ): \"\"\"Convert glossary data to HTML.\"\"\" if not config . lang : raise McColeExc ( \"Cannot convert glossary: no language in configuration.\" ) try : internal = { entry [ \"key\" ]: entry [ config . lang ][ \"term\" ] for entry in config . gloss_data } except KeyError as exc : raise McColeExc ( f \"Glossary entry or entries missing 'key' { exc } .\" ) entries = [ _gloss_to_markdown ( entry , config . lang , internal , seen ) for entry in config . gloss_data ] text = \" \\n\\n \" . join ( entries ) md = make_md () html = md . render ( text ) return html","title":"gloss_to_html()"},{"location":"gloss/#mccole.gloss.load_gloss","text":"Read glossary file if there is one. Source code in mccole/gloss.py def load_gloss ( config ): \"\"\"Read glossary file if there is one.\"\"\" if not config . gloss : return try : with open ( config . gloss , \"r\" ) as reader : config . gloss_data = yaml . safe_load ( reader ) or [] except OSError : raise McColeExc ( f \"Unable to open glossary file { config . gloss } .\" ) config . gloss_keys = { entry [ \"key\" ] for entry in config . gloss_data }","title":"load_gloss()"},{"location":"include/","text":"File Inclusion Handle file inclusion. inclusion_to_html ( info , spec ) Handle a file inclusion. Source code in mccole/include.py def inclusion_to_html ( info , spec ): \"\"\"Handle a file inclusion.\"\"\" for ( pat , handler ) in ( ( INCLUSION_FILE , _file ), ( INCLUSION_KEEP , _keep ), ( INCLUSION_OMIT , _omit ), ( INCLUSION_KEEP_OMIT , _keep_omit ), ( INCLUSION_MULTI , _multi ), ): match = pat . search ( spec ) if match : return handler ( info , match ) LOGGER . error ( f \"Unrecognized inclusion spec ' { spec } ' in { info . src } .\" ) return \"\"","title":"File Inclusion"},{"location":"include/#file-inclusion","text":"Handle file inclusion.","title":"File Inclusion"},{"location":"include/#mccole.include.inclusion_to_html","text":"Handle a file inclusion. Source code in mccole/include.py def inclusion_to_html ( info , spec ): \"\"\"Handle a file inclusion.\"\"\" for ( pat , handler ) in ( ( INCLUSION_FILE , _file ), ( INCLUSION_KEEP , _keep ), ( INCLUSION_OMIT , _omit ), ( INCLUSION_KEEP_OMIT , _keep_omit ), ( INCLUSION_MULTI , _multi ), ): match = pat . search ( spec ) if match : return handler ( info , match ) LOGGER . error ( f \"Unrecognized inclusion spec ' { spec } ' in { info . src } .\" ) return \"\"","title":"inclusion_to_html()"},{"location":"license/","text":"The MIT License (MIT) Copyright \u00a9 2021 Greg Wilson Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#the-mit-license-mit","text":"Copyright \u00a9 2021 Greg Wilson Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"The MIT License (MIT)"},{"location":"mccole/","text":"Main Driver Main entry point. main ( args ) Parse arguments and execute. Source code in mccole/mccole.py def main ( args ): \"\"\"Parse arguments and execute.\"\"\" try : options = _parse_args ( args ) if _resources ( options ): return _setup ( options ) config = load_config ( options ) load_bib ( config ) load_gloss ( config ) collect_pages ( config ) tokenize ( config ) xref = cross_reference ( config ) if not options . dryrun : _clean_output ( options , config ) copy_files ( config ) seen = generate_pages ( config , xref , not options . dryrun ) show ( options , config , xref , seen ) check ( options , config , xref , seen ) _warn_unused ( options , config , xref , seen ) run_server ( options , config . dst ) except McColeExc as exc : LOGGER . error ( f \"McCole failed: { exc . msg } \" ) show_template_list () Show available HTML templates. Source code in mccole/mccole.py def show_template_list (): \"\"\"Show available HTML templates.\"\"\" filenames = pkg_resources . resource_listdir ( __name__ , \"data\" ) filenames = [ f for f in filenames if f . endswith ( \".html\" )] if not filenames : print ( \"No templates\" ) else : for f in filenames : print ( f ) return True","title":"Main Driver"},{"location":"mccole/#main-driver","text":"Main entry point.","title":"Main Driver"},{"location":"mccole/#mccole.mccole.main","text":"Parse arguments and execute. Source code in mccole/mccole.py def main ( args ): \"\"\"Parse arguments and execute.\"\"\" try : options = _parse_args ( args ) if _resources ( options ): return _setup ( options ) config = load_config ( options ) load_bib ( config ) load_gloss ( config ) collect_pages ( config ) tokenize ( config ) xref = cross_reference ( config ) if not options . dryrun : _clean_output ( options , config ) copy_files ( config ) seen = generate_pages ( config , xref , not options . dryrun ) show ( options , config , xref , seen ) check ( options , config , xref , seen ) _warn_unused ( options , config , xref , seen ) run_server ( options , config . dst ) except McColeExc as exc : LOGGER . error ( f \"McCole failed: { exc . msg } \" )","title":"main()"},{"location":"mccole/#mccole.mccole.show_template_list","text":"Show available HTML templates. Source code in mccole/mccole.py def show_template_list (): \"\"\"Show available HTML templates.\"\"\" filenames = pkg_resources . resource_listdir ( __name__ , \"data\" ) filenames = [ f for f in filenames if f . endswith ( \".html\" )] if not filenames : print ( \"No templates\" ) else : for f in filenames : print ( f ) return True","title":"show_template_list()"},{"location":"patterns/","text":"Patterns in Source Files Patterns in input.","title":"Patterns"},{"location":"patterns/#patterns-in-source-files","text":"Patterns in input.","title":"Patterns in Source Files"},{"location":"render/","text":"Rendering HTML Convert token streams to HTML. McColeRenderer ( RendererHTML ) Translate token stream to HTML. Source code in mccole/render.py class McColeRenderer ( RendererHTML ): \"\"\"Translate token stream to HTML.\"\"\" def __init__ ( self , config , xref , seen , info ): \"\"\"Remember settings and cross-reference information.\"\"\" super () . __init__ ( self ) self . config = config self . xref = xref self . seen = seen self . info = info # ------------------------------------------------------------------ def heading_open ( self , tokens , idx , options , env ): \"\"\"Add IDs to headings if requested.\"\"\" inline = tokens [ idx + 1 ] assert inline . type == \"inline\" for child in inline . children : if child . type == \"text\" : match = HEADING_CLASS . search ( child . content ) if match : heading_class = match . group ( 3 ) child . content = child . content . replace ( match . group ( 2 ), \"\" ) tokens [ idx ] . attrSet ( \"class\" , heading_class ) match = HEADING_ID . search ( child . content ) if match : heading_id = match . group ( 3 ) child . content = child . content . replace ( match . group ( 2 ), \"\" ) tokens [ idx ] . attrSet ( \"id\" , heading_id ) result = RendererHTML . renderToken ( self , tokens , idx , options , env ) return result def html_block ( self , tokens , idx , options , env ): \"\"\"Look for special entries for bibliography, glossary, etc.\"\"\" for ( pat , method ) in ( ( COMMENT , self . _comment ), ( DIV_CENTER , self . _copy ), ( FIGURE , self . _figure ), ( INCLUSION , self . _inclusion ), ( TABLE_RAW , self . _raw_table ), ( TABLE_START , self . _table ), ( DIV_CLOSE , self . _copy ), # must come last ): match = pat . search ( tokens [ idx ] . content ) if match : return method ( tokens , idx , match ) return self . html_inline ( tokens , idx , options , env ) def html_inline ( self , tokens , idx , options , env ): \"\"\"Fill in span elements with cross-references.\"\"\" token = tokens [ idx ] for ( pat , method ) in ( ( BREAK , self . _copy ), ( CODE_OPEN , self . _copy ), ( CODE_CLOSE , self . _copy ), ( EM_OPEN , self . _copy ), ( EM_CLOSE , self . _copy ), ( CITE , self . _cite ), ( COMMENT , self . _comment ), ( FIGURE_REF , self . _figure_ref ), ( GLOSS_REF , self . _gloss_ref ), ( GLOSS_INDEX , self . _gloss_index ), ( INDEX_DEF , self . _index_def ), ( LINECOUNT , self . _linecount ), ( SECTION_REF , self . _section_ref ), ( STRONG_OPEN , self . _copy ), ( STRONG_CLOSE , self . _copy ), ( SUP_OPEN , self . _copy ), ( SUP_CLOSE , self . _copy ), ( TABLE_REF , self . _table_ref ), ): match = pat . search ( token . content ) if match : return method ( tokens , idx , match ) # Text for citations generated by `_cite`, so ignore closing tag. if tokens [ idx ] . content == \"</cite>\" : return \"\" # Closing spans for glossary and index references are retained. if tokens [ idx ] . content == \"</span>\" : return \"</span>\" LOGGER . error ( f \"Unknown HTML { loc ( self . info , token ) } : { token . content } \" ) return str ( tokens [ idx ] . content ) # ------------------------------------------------------------------ def _cite ( self , tokens , idx , match ): \"\"\"Translate bibliographic citations.\"\"\" token = tokens [ idx + 1 ] assert token . type == \"text\" keys = [ k . strip () for k in token . content . split ( \",\" )] self . _check_for_unknown ( \"citation\" , \"bib_keys\" , token , * keys ) self . seen . cite . update ( keys ) refs = [ f '<a href=\"../bibliography/# { k } \"> { k } </a>' for k in keys ] token . content = \"\" # Erase citation key text so it won't be echoed. return f \"[ { ', ' . join ( refs ) } ]\" def _comment ( self , tokens , idx , match ): \"\"\"Copy comments verbatim for now.\"\"\" return tokens [ idx ] . content def _copy ( self , tokens , idx , match ): \"\"\"Copy HTML verbatim.\"\"\" return tokens [ idx ] . content def _figure ( self , tokens , idx , match ): \"\"\"Generate a figure.\"\"\" text = tokens [ idx ] . content figure_id = FIGURE_ID . search ( text ) . group ( 1 ) label = self . xref . fig_id_to_index . get ( figure_id , None ) if label : label = \".\" . join ( str ( i ) for i in label ) else : label = self . _report_unknown ( \"figure ID\" , figure_id , tokens [ idx ]) original_caption = FIGURE_CAP . search ( text ) . group ( 1 ) term = self . _choose_term ( \"figure\" ) fixed_caption = f \" { term } &nbsp; { label } : { original_caption } \" return text . replace ( original_caption , fixed_caption ) def _figure_ref ( self , tokens , idx , match ): \"\"\"Fill in figure reference.\"\"\" key = match . group ( 1 ) self . seen . figure_ref . add ( key ) label = self . _make_crossref_label ( \"fig_id_to_index\" , key , \"figure\" ) href = self . _make_crossref_href ( \"figure\" , \"fig_id_to_slug\" , key , tokens [ idx ]) return f '<a class=\"figref\" href=\" { href } \"> { label } </a>' def _gloss_ref ( self , tokens , idx , match ): \"\"\"Fill in glossary definition.\"\"\" key = match . group ( 1 ) self . _check_for_unknown ( \"glossary\" , \"gloss_keys\" , tokens [ idx ], key ) self . seen . gloss_ref . add ( key ) return f '<span g=\" { key } \">' def _gloss_index ( self , tokens , idx , match ): \"\"\"Fill in glossary+index definition.\"\"\" gloss_key = match . group ( 1 ) index_key = match . group ( 2 ) self . _check_for_unknown ( \"glossary\" , \"gloss_keys\" , tokens [ idx ], gloss_key ) self . seen . gloss_ref . add ( gloss_key ) self . seen . index_ref . add ( index_key ) return f '<span g=\" { gloss_key } \" i=\" { index_key } \">' def _inclusion ( self , tokens , idx , match ): \"\"\"Fill in file inclusion.\"\"\" return inclusion_to_html ( self . info , match . group ( 1 )) def _index_def ( self , tokens , idx , match ): \"\"\"Fill in index definition.\"\"\" key = match . group ( 1 ) return f '<span i=\" { key } \">' def _linecount ( self , tokens , idx , match ): \"\"\"Count lines in file.\"\"\" filename = make_inclusion_filename ( self . info , match . group ( 1 )) try : with open ( filename , \"r\" ) as reader : return str ( len ( reader . readlines ())) except OSError : err ( f \"Unable to open { filename } to count lines\" , self . info , tokens [ idx ]) return MISSING def _raw_table ( self , tokens , idx , match ): \"\"\"Pass raw tables through unaltered.\"\"\" return tokens [ idx ] . content def _section_ref ( self , tokens , idx , match ): \"\"\"Fill in section reference.\"\"\" section_id = match . group ( 1 ) label = self . xref . hd_id_to_index . get ( section_id , None ) if label : word = self . _choose_term ( \"section\" , label ) label = \".\" . join ( str ( i ) for i in label ) label = f \" { word } &nbsp; { label } \" else : # Error reporting handled elsewhere label = MISSING href = self . _make_crossref_href ( \"section\" , \"hd_id_to_slug\" , section_id , tokens [ idx ] ) return f '<a class=\"secref\" href=\" { href } \"> { label } </a>' def _table ( self , tokens , idx , match ): \"\"\"Parse a table nested inside a div.\"\"\" opening , caption , body = self . _get_table_fields ( tokens [ idx ]) md = make_md () html = md . render ( body ) html = html . replace ( \"<table>\" , f \" { opening }{ caption } \" ) return html def _table_ref ( self , tokens , idx , match ): \"\"\"Fill in table reference.\"\"\" key = match . group ( 1 ) self . seen . table_ref . add ( key ) label = self . _make_crossref_label ( \"tbl_id_to_index\" , key , \"table\" ) term = self . _choose_term ( \"table\" ) href = self . _make_crossref_href ( \"table\" , \"tbl_id_to_slug\" , key , tokens [ idx ]) return f '<a class=\"tblref\" href=\" { href } \"> { label } </a>' # ------------------------------------------------------------------ def _check_for_unknown ( self , kind , lookup_key , token , * item_keys ): \"\"\"Report any missing keys.\"\"\" missing = [ k for k in item_keys if k not in getattr ( self . config , lookup_key )] if missing : missing = \", \" . join ( missing ) self . _report_unknown ( kind , missing , token ) def _choose_term ( self , kind , label = None ): \"\"\"Choose appropriate word for part of document.\"\"\" terms = self . config . terms [ self . config . lang ] if kind in { \"figure\" , \"table\" }: return terms [ kind ] if kind == \"section\" : if len ( label ) > 1 : return terms [ \"section\" ] if label [ 0 ] . isdigit (): return terms [ \"chapter\" ] return terms [ \"appendix\" ] LOGGER . error ( f \"Unknown kind of term { kind } \" ) return MISSING def _get_table_fields ( self , token ): \"\"\"Extract and format table information.\"\"\" content = token . content table_id = TABLE_ID . search ( content ) cap = TABLE_CAP . search ( content ) body = TABLE_BODY . search ( content ) if table_id : table_id = table_id . group ( 1 ) label = self . xref . tbl_id_to_index . get ( table_id , None ) else : table_id = MISSING label = None if label : label = \".\" . join ( str ( i ) for i in label ) else : label = self . _report_unknown ( \"table ID\" , table_id , token ) if cap : cap = cap . group ( 1 ) else : err ( f \"Table missing caption\" , self . info , token ) cap = MISSING if body : body = body . group ( 1 ) else : err ( f \"Table missing body\" , self . info , token ) body = \"\" opening = f '<table id=\" { table_id } \">' caption = f \"<caption>Table&nbsp; { label } : { cap } </caption>\" return opening , caption , body def _make_crossref_href ( self , kind , lookup_key , item_key , token ): \"\"\"Make cross-reference URL.\"\"\" slug = getattr ( self . xref , lookup_key ) . get ( item_key , None ) if slug is None : err ( f \"Unknown { kind } key { item_key } \" , self . info , token ) return MISSING elif slug == self . info . slug : return f \"# { item_key } \" else : return f \" { self . info . to_root } / { slug } /# { item_key } \" def _make_crossref_label ( self , lookup_key , item_key , kind ): \"\"\"Make cross-reference label text.\"\"\" label = getattr ( self . xref , lookup_key ) . get ( item_key , None ) if label : label = \".\" . join ( str ( i ) for i in label ) else : label = MISSING prefix = self . _choose_term ( kind ) return f \" { prefix } &nbsp; { label } \" def _report_unknown ( self , kind , missing_id , token ): err ( f \"Unknown { kind } key { missing_id } \" , self . info , token ) return MISSING __init__ ( self , config , xref , seen , info ) special Remember settings and cross-reference information. Source code in mccole/render.py def __init__ ( self , config , xref , seen , info ): \"\"\"Remember settings and cross-reference information.\"\"\" super () . __init__ ( self ) self . config = config self . xref = xref self . seen = seen self . info = info heading_open ( self , tokens , idx , options , env ) Add IDs to headings if requested. Source code in mccole/render.py def heading_open ( self , tokens , idx , options , env ): \"\"\"Add IDs to headings if requested.\"\"\" inline = tokens [ idx + 1 ] assert inline . type == \"inline\" for child in inline . children : if child . type == \"text\" : match = HEADING_CLASS . search ( child . content ) if match : heading_class = match . group ( 3 ) child . content = child . content . replace ( match . group ( 2 ), \"\" ) tokens [ idx ] . attrSet ( \"class\" , heading_class ) match = HEADING_ID . search ( child . content ) if match : heading_id = match . group ( 3 ) child . content = child . content . replace ( match . group ( 2 ), \"\" ) tokens [ idx ] . attrSet ( \"id\" , heading_id ) result = RendererHTML . renderToken ( self , tokens , idx , options , env ) return result html_block ( self , tokens , idx , options , env ) Look for special entries for bibliography, glossary, etc. Source code in mccole/render.py def html_block ( self , tokens , idx , options , env ): \"\"\"Look for special entries for bibliography, glossary, etc.\"\"\" for ( pat , method ) in ( ( COMMENT , self . _comment ), ( DIV_CENTER , self . _copy ), ( FIGURE , self . _figure ), ( INCLUSION , self . _inclusion ), ( TABLE_RAW , self . _raw_table ), ( TABLE_START , self . _table ), ( DIV_CLOSE , self . _copy ), # must come last ): match = pat . search ( tokens [ idx ] . content ) if match : return method ( tokens , idx , match ) return self . html_inline ( tokens , idx , options , env ) html_inline ( self , tokens , idx , options , env ) Fill in span elements with cross-references. Source code in mccole/render.py def html_inline ( self , tokens , idx , options , env ): \"\"\"Fill in span elements with cross-references.\"\"\" token = tokens [ idx ] for ( pat , method ) in ( ( BREAK , self . _copy ), ( CODE_OPEN , self . _copy ), ( CODE_CLOSE , self . _copy ), ( EM_OPEN , self . _copy ), ( EM_CLOSE , self . _copy ), ( CITE , self . _cite ), ( COMMENT , self . _comment ), ( FIGURE_REF , self . _figure_ref ), ( GLOSS_REF , self . _gloss_ref ), ( GLOSS_INDEX , self . _gloss_index ), ( INDEX_DEF , self . _index_def ), ( LINECOUNT , self . _linecount ), ( SECTION_REF , self . _section_ref ), ( STRONG_OPEN , self . _copy ), ( STRONG_CLOSE , self . _copy ), ( SUP_OPEN , self . _copy ), ( SUP_CLOSE , self . _copy ), ( TABLE_REF , self . _table_ref ), ): match = pat . search ( token . content ) if match : return method ( tokens , idx , match ) # Text for citations generated by `_cite`, so ignore closing tag. if tokens [ idx ] . content == \"</cite>\" : return \"\" # Closing spans for glossary and index references are retained. if tokens [ idx ] . content == \"</span>\" : return \"</span>\" LOGGER . error ( f \"Unknown HTML { loc ( self . info , token ) } : { token . content } \" ) return str ( tokens [ idx ] . content ) render ( config , xref , seen , info ) Turn token stream into HTML. Source code in mccole/render.py def render ( config , xref , seen , info ): \"\"\"Turn token stream into HTML.\"\"\" options = OptionsDict ( commonmark . make ()[ \"options\" ]) renderer = McColeRenderer ( config , xref , seen , info ) return renderer . render ( info . tokens , options , {})","title":"Render HTML"},{"location":"render/#rendering-html","text":"Convert token streams to HTML.","title":"Rendering HTML"},{"location":"render/#mccole.render.McColeRenderer","text":"Translate token stream to HTML. Source code in mccole/render.py class McColeRenderer ( RendererHTML ): \"\"\"Translate token stream to HTML.\"\"\" def __init__ ( self , config , xref , seen , info ): \"\"\"Remember settings and cross-reference information.\"\"\" super () . __init__ ( self ) self . config = config self . xref = xref self . seen = seen self . info = info # ------------------------------------------------------------------ def heading_open ( self , tokens , idx , options , env ): \"\"\"Add IDs to headings if requested.\"\"\" inline = tokens [ idx + 1 ] assert inline . type == \"inline\" for child in inline . children : if child . type == \"text\" : match = HEADING_CLASS . search ( child . content ) if match : heading_class = match . group ( 3 ) child . content = child . content . replace ( match . group ( 2 ), \"\" ) tokens [ idx ] . attrSet ( \"class\" , heading_class ) match = HEADING_ID . search ( child . content ) if match : heading_id = match . group ( 3 ) child . content = child . content . replace ( match . group ( 2 ), \"\" ) tokens [ idx ] . attrSet ( \"id\" , heading_id ) result = RendererHTML . renderToken ( self , tokens , idx , options , env ) return result def html_block ( self , tokens , idx , options , env ): \"\"\"Look for special entries for bibliography, glossary, etc.\"\"\" for ( pat , method ) in ( ( COMMENT , self . _comment ), ( DIV_CENTER , self . _copy ), ( FIGURE , self . _figure ), ( INCLUSION , self . _inclusion ), ( TABLE_RAW , self . _raw_table ), ( TABLE_START , self . _table ), ( DIV_CLOSE , self . _copy ), # must come last ): match = pat . search ( tokens [ idx ] . content ) if match : return method ( tokens , idx , match ) return self . html_inline ( tokens , idx , options , env ) def html_inline ( self , tokens , idx , options , env ): \"\"\"Fill in span elements with cross-references.\"\"\" token = tokens [ idx ] for ( pat , method ) in ( ( BREAK , self . _copy ), ( CODE_OPEN , self . _copy ), ( CODE_CLOSE , self . _copy ), ( EM_OPEN , self . _copy ), ( EM_CLOSE , self . _copy ), ( CITE , self . _cite ), ( COMMENT , self . _comment ), ( FIGURE_REF , self . _figure_ref ), ( GLOSS_REF , self . _gloss_ref ), ( GLOSS_INDEX , self . _gloss_index ), ( INDEX_DEF , self . _index_def ), ( LINECOUNT , self . _linecount ), ( SECTION_REF , self . _section_ref ), ( STRONG_OPEN , self . _copy ), ( STRONG_CLOSE , self . _copy ), ( SUP_OPEN , self . _copy ), ( SUP_CLOSE , self . _copy ), ( TABLE_REF , self . _table_ref ), ): match = pat . search ( token . content ) if match : return method ( tokens , idx , match ) # Text for citations generated by `_cite`, so ignore closing tag. if tokens [ idx ] . content == \"</cite>\" : return \"\" # Closing spans for glossary and index references are retained. if tokens [ idx ] . content == \"</span>\" : return \"</span>\" LOGGER . error ( f \"Unknown HTML { loc ( self . info , token ) } : { token . content } \" ) return str ( tokens [ idx ] . content ) # ------------------------------------------------------------------ def _cite ( self , tokens , idx , match ): \"\"\"Translate bibliographic citations.\"\"\" token = tokens [ idx + 1 ] assert token . type == \"text\" keys = [ k . strip () for k in token . content . split ( \",\" )] self . _check_for_unknown ( \"citation\" , \"bib_keys\" , token , * keys ) self . seen . cite . update ( keys ) refs = [ f '<a href=\"../bibliography/# { k } \"> { k } </a>' for k in keys ] token . content = \"\" # Erase citation key text so it won't be echoed. return f \"[ { ', ' . join ( refs ) } ]\" def _comment ( self , tokens , idx , match ): \"\"\"Copy comments verbatim for now.\"\"\" return tokens [ idx ] . content def _copy ( self , tokens , idx , match ): \"\"\"Copy HTML verbatim.\"\"\" return tokens [ idx ] . content def _figure ( self , tokens , idx , match ): \"\"\"Generate a figure.\"\"\" text = tokens [ idx ] . content figure_id = FIGURE_ID . search ( text ) . group ( 1 ) label = self . xref . fig_id_to_index . get ( figure_id , None ) if label : label = \".\" . join ( str ( i ) for i in label ) else : label = self . _report_unknown ( \"figure ID\" , figure_id , tokens [ idx ]) original_caption = FIGURE_CAP . search ( text ) . group ( 1 ) term = self . _choose_term ( \"figure\" ) fixed_caption = f \" { term } &nbsp; { label } : { original_caption } \" return text . replace ( original_caption , fixed_caption ) def _figure_ref ( self , tokens , idx , match ): \"\"\"Fill in figure reference.\"\"\" key = match . group ( 1 ) self . seen . figure_ref . add ( key ) label = self . _make_crossref_label ( \"fig_id_to_index\" , key , \"figure\" ) href = self . _make_crossref_href ( \"figure\" , \"fig_id_to_slug\" , key , tokens [ idx ]) return f '<a class=\"figref\" href=\" { href } \"> { label } </a>' def _gloss_ref ( self , tokens , idx , match ): \"\"\"Fill in glossary definition.\"\"\" key = match . group ( 1 ) self . _check_for_unknown ( \"glossary\" , \"gloss_keys\" , tokens [ idx ], key ) self . seen . gloss_ref . add ( key ) return f '<span g=\" { key } \">' def _gloss_index ( self , tokens , idx , match ): \"\"\"Fill in glossary+index definition.\"\"\" gloss_key = match . group ( 1 ) index_key = match . group ( 2 ) self . _check_for_unknown ( \"glossary\" , \"gloss_keys\" , tokens [ idx ], gloss_key ) self . seen . gloss_ref . add ( gloss_key ) self . seen . index_ref . add ( index_key ) return f '<span g=\" { gloss_key } \" i=\" { index_key } \">' def _inclusion ( self , tokens , idx , match ): \"\"\"Fill in file inclusion.\"\"\" return inclusion_to_html ( self . info , match . group ( 1 )) def _index_def ( self , tokens , idx , match ): \"\"\"Fill in index definition.\"\"\" key = match . group ( 1 ) return f '<span i=\" { key } \">' def _linecount ( self , tokens , idx , match ): \"\"\"Count lines in file.\"\"\" filename = make_inclusion_filename ( self . info , match . group ( 1 )) try : with open ( filename , \"r\" ) as reader : return str ( len ( reader . readlines ())) except OSError : err ( f \"Unable to open { filename } to count lines\" , self . info , tokens [ idx ]) return MISSING def _raw_table ( self , tokens , idx , match ): \"\"\"Pass raw tables through unaltered.\"\"\" return tokens [ idx ] . content def _section_ref ( self , tokens , idx , match ): \"\"\"Fill in section reference.\"\"\" section_id = match . group ( 1 ) label = self . xref . hd_id_to_index . get ( section_id , None ) if label : word = self . _choose_term ( \"section\" , label ) label = \".\" . join ( str ( i ) for i in label ) label = f \" { word } &nbsp; { label } \" else : # Error reporting handled elsewhere label = MISSING href = self . _make_crossref_href ( \"section\" , \"hd_id_to_slug\" , section_id , tokens [ idx ] ) return f '<a class=\"secref\" href=\" { href } \"> { label } </a>' def _table ( self , tokens , idx , match ): \"\"\"Parse a table nested inside a div.\"\"\" opening , caption , body = self . _get_table_fields ( tokens [ idx ]) md = make_md () html = md . render ( body ) html = html . replace ( \"<table>\" , f \" { opening }{ caption } \" ) return html def _table_ref ( self , tokens , idx , match ): \"\"\"Fill in table reference.\"\"\" key = match . group ( 1 ) self . seen . table_ref . add ( key ) label = self . _make_crossref_label ( \"tbl_id_to_index\" , key , \"table\" ) term = self . _choose_term ( \"table\" ) href = self . _make_crossref_href ( \"table\" , \"tbl_id_to_slug\" , key , tokens [ idx ]) return f '<a class=\"tblref\" href=\" { href } \"> { label } </a>' # ------------------------------------------------------------------ def _check_for_unknown ( self , kind , lookup_key , token , * item_keys ): \"\"\"Report any missing keys.\"\"\" missing = [ k for k in item_keys if k not in getattr ( self . config , lookup_key )] if missing : missing = \", \" . join ( missing ) self . _report_unknown ( kind , missing , token ) def _choose_term ( self , kind , label = None ): \"\"\"Choose appropriate word for part of document.\"\"\" terms = self . config . terms [ self . config . lang ] if kind in { \"figure\" , \"table\" }: return terms [ kind ] if kind == \"section\" : if len ( label ) > 1 : return terms [ \"section\" ] if label [ 0 ] . isdigit (): return terms [ \"chapter\" ] return terms [ \"appendix\" ] LOGGER . error ( f \"Unknown kind of term { kind } \" ) return MISSING def _get_table_fields ( self , token ): \"\"\"Extract and format table information.\"\"\" content = token . content table_id = TABLE_ID . search ( content ) cap = TABLE_CAP . search ( content ) body = TABLE_BODY . search ( content ) if table_id : table_id = table_id . group ( 1 ) label = self . xref . tbl_id_to_index . get ( table_id , None ) else : table_id = MISSING label = None if label : label = \".\" . join ( str ( i ) for i in label ) else : label = self . _report_unknown ( \"table ID\" , table_id , token ) if cap : cap = cap . group ( 1 ) else : err ( f \"Table missing caption\" , self . info , token ) cap = MISSING if body : body = body . group ( 1 ) else : err ( f \"Table missing body\" , self . info , token ) body = \"\" opening = f '<table id=\" { table_id } \">' caption = f \"<caption>Table&nbsp; { label } : { cap } </caption>\" return opening , caption , body def _make_crossref_href ( self , kind , lookup_key , item_key , token ): \"\"\"Make cross-reference URL.\"\"\" slug = getattr ( self . xref , lookup_key ) . get ( item_key , None ) if slug is None : err ( f \"Unknown { kind } key { item_key } \" , self . info , token ) return MISSING elif slug == self . info . slug : return f \"# { item_key } \" else : return f \" { self . info . to_root } / { slug } /# { item_key } \" def _make_crossref_label ( self , lookup_key , item_key , kind ): \"\"\"Make cross-reference label text.\"\"\" label = getattr ( self . xref , lookup_key ) . get ( item_key , None ) if label : label = \".\" . join ( str ( i ) for i in label ) else : label = MISSING prefix = self . _choose_term ( kind ) return f \" { prefix } &nbsp; { label } \" def _report_unknown ( self , kind , missing_id , token ): err ( f \"Unknown { kind } key { missing_id } \" , self . info , token ) return MISSING","title":"McColeRenderer"},{"location":"render/#mccole.render.McColeRenderer.__init__","text":"Remember settings and cross-reference information. Source code in mccole/render.py def __init__ ( self , config , xref , seen , info ): \"\"\"Remember settings and cross-reference information.\"\"\" super () . __init__ ( self ) self . config = config self . xref = xref self . seen = seen self . info = info","title":"__init__()"},{"location":"render/#mccole.render.McColeRenderer.heading_open","text":"Add IDs to headings if requested. Source code in mccole/render.py def heading_open ( self , tokens , idx , options , env ): \"\"\"Add IDs to headings if requested.\"\"\" inline = tokens [ idx + 1 ] assert inline . type == \"inline\" for child in inline . children : if child . type == \"text\" : match = HEADING_CLASS . search ( child . content ) if match : heading_class = match . group ( 3 ) child . content = child . content . replace ( match . group ( 2 ), \"\" ) tokens [ idx ] . attrSet ( \"class\" , heading_class ) match = HEADING_ID . search ( child . content ) if match : heading_id = match . group ( 3 ) child . content = child . content . replace ( match . group ( 2 ), \"\" ) tokens [ idx ] . attrSet ( \"id\" , heading_id ) result = RendererHTML . renderToken ( self , tokens , idx , options , env ) return result","title":"heading_open()"},{"location":"render/#mccole.render.McColeRenderer.html_block","text":"Look for special entries for bibliography, glossary, etc. Source code in mccole/render.py def html_block ( self , tokens , idx , options , env ): \"\"\"Look for special entries for bibliography, glossary, etc.\"\"\" for ( pat , method ) in ( ( COMMENT , self . _comment ), ( DIV_CENTER , self . _copy ), ( FIGURE , self . _figure ), ( INCLUSION , self . _inclusion ), ( TABLE_RAW , self . _raw_table ), ( TABLE_START , self . _table ), ( DIV_CLOSE , self . _copy ), # must come last ): match = pat . search ( tokens [ idx ] . content ) if match : return method ( tokens , idx , match ) return self . html_inline ( tokens , idx , options , env )","title":"html_block()"},{"location":"render/#mccole.render.McColeRenderer.html_inline","text":"Fill in span elements with cross-references. Source code in mccole/render.py def html_inline ( self , tokens , idx , options , env ): \"\"\"Fill in span elements with cross-references.\"\"\" token = tokens [ idx ] for ( pat , method ) in ( ( BREAK , self . _copy ), ( CODE_OPEN , self . _copy ), ( CODE_CLOSE , self . _copy ), ( EM_OPEN , self . _copy ), ( EM_CLOSE , self . _copy ), ( CITE , self . _cite ), ( COMMENT , self . _comment ), ( FIGURE_REF , self . _figure_ref ), ( GLOSS_REF , self . _gloss_ref ), ( GLOSS_INDEX , self . _gloss_index ), ( INDEX_DEF , self . _index_def ), ( LINECOUNT , self . _linecount ), ( SECTION_REF , self . _section_ref ), ( STRONG_OPEN , self . _copy ), ( STRONG_CLOSE , self . _copy ), ( SUP_OPEN , self . _copy ), ( SUP_CLOSE , self . _copy ), ( TABLE_REF , self . _table_ref ), ): match = pat . search ( token . content ) if match : return method ( tokens , idx , match ) # Text for citations generated by `_cite`, so ignore closing tag. if tokens [ idx ] . content == \"</cite>\" : return \"\" # Closing spans for glossary and index references are retained. if tokens [ idx ] . content == \"</span>\" : return \"</span>\" LOGGER . error ( f \"Unknown HTML { loc ( self . info , token ) } : { token . content } \" ) return str ( tokens [ idx ] . content )","title":"html_inline()"},{"location":"render/#mccole.render.render","text":"Turn token stream into HTML. Source code in mccole/render.py def render ( config , xref , seen , info ): \"\"\"Turn token stream into HTML.\"\"\" options = OptionsDict ( commonmark . make ()[ \"options\" ]) renderer = McColeRenderer ( config , xref , seen , info ) return renderer . render ( info . tokens , options , {})","title":"render()"},{"location":"server/","text":"Preview Server Run simple server for previewing. server ( TCPServer ) Allow address to be re-used so that server can be restarted immediately. Source code in mccole/server.py class server ( socketserver . TCPServer ): \"\"\"Allow address to be re-used so that server can be restarted immediately.\"\"\" allow_reuse_address = True run_server ( options , root_dir ) Run web server on specified port. Source code in mccole/server.py def run_server ( options , root_dir ): \"\"\"Run web server on specified port.\"\"\" if not options . run : return class handler ( http . server . SimpleHTTPRequestHandler ): \"\"\"Wrap the root directory.\"\"\" def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , directory = root_dir , ** kwargs ) with server (( \"\" , options . run ), handler ) as httpd : print ( f \"serving on port { options . run } ...\" ) httpd . serve_forever ()","title":"Preview Server"},{"location":"server/#preview-server","text":"Run simple server for previewing.","title":"Preview Server"},{"location":"server/#mccole.server.server","text":"Allow address to be re-used so that server can be restarted immediately. Source code in mccole/server.py class server ( socketserver . TCPServer ): \"\"\"Allow address to be re-used so that server can be restarted immediately.\"\"\" allow_reuse_address = True","title":"server"},{"location":"server/#mccole.server.run_server","text":"Run web server on specified port. Source code in mccole/server.py def run_server ( options , root_dir ): \"\"\"Run web server on specified port.\"\"\" if not options . run : return class handler ( http . server . SimpleHTTPRequestHandler ): \"\"\"Wrap the root directory.\"\"\" def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , directory = root_dir , ** kwargs ) with server (( \"\" , options . run ), handler ) as httpd : print ( f \"serving on port { options . run } ...\" ) httpd . serve_forever ()","title":"run_server()"},{"location":"show/","text":"Show Show internal state for debugging. show ( options , config , xref , seen ) Show internal state for debugging. Source code in mccole/show.py def show ( options , config , xref , seen ): \"\"\"Show internal state for debugging.\"\"\" if \"bib\" in options . data : _show_bib ( options , config , seen ) if \"gloss\" in options . data : _show_gloss ( options , config , seen ) if \"pages\" in options . data : _show_pages ( options , config ) if \"xref\" in options . data : _show_xref ( options , xref )","title":"Show Standard Files"},{"location":"show/#show","text":"Show internal state for debugging.","title":"Show"},{"location":"show/#mccole.show.show","text":"Show internal state for debugging. Source code in mccole/show.py def show ( options , config , xref , seen ): \"\"\"Show internal state for debugging.\"\"\" if \"bib\" in options . data : _show_bib ( options , config , seen ) if \"gloss\" in options . data : _show_gloss ( options , config , seen ) if \"pages\" in options . data : _show_pages ( options , config ) if \"xref\" in options . data : _show_xref ( options , xref )","title":"show()"},{"location":"template/","text":"Template Evaluate page templates to fill in content. fill_template ( config , xref , info , site , html ) Fill in page template if present. Source code in mccole/template.py def fill_template ( config , xref , info , site , html ): \"\"\"Fill in page template if present.\"\"\" template_name = info . metadata . get ( \"template\" , None ) if template_name is None : template_name = info . template if template_name is None : LOGGER . error ( f \"No template in { info . src } .\" ) return html template = config . template . get ( template_name , None ) if template is None : LOGGER . error ( f \"Unknown template { template_name } in { info . src } .\" ) return html LOGGER . debug ( f \"filling { template_name } for { info . src } \" ) site . toc = lambda : _site_toc ( config , xref ) page = SN ( content = lambda : html , keyterms = lambda : _keyterms ( config , info ), lede = lambda : _lede ( config , info ), title = lambda : f '<h1 id=\" { info . slug } \"> { info . title } </h1>' , to_root = lambda : info . to_root , toc = lambda : _page_toc ( info , xref ) ) return _fill ( template_name , template , site , page ) load_templates ( config ) Load page templates. Source code in mccole/template.py def load_templates ( config ): \"\"\"Load page templates.\"\"\" config . template = {} for filename in glob ( f \" { TEMPLATE_DIR } /*.html\" ): label = os . path . basename ( filename ) with open ( filename , \"r\" ) as reader : text = reader . read () if \"'''\" in text : LOGGER . warning ( f \"Template { filename } contains triple quote '''.\" ) config . template [ label ] = text make_site_object ( config , seen ) Make object with site values for evaluation. Source code in mccole/template.py def make_site_object ( config , seen ): \"\"\"Make object with site values for evaluation.\"\"\" now = datetime . today () . strftime ( \"%Y-%m- %d \" ) subtitle = ( f '<h2 class=\"subtitle\"> { config . subtitle } </h2>' if config . subtitle else \"\" ) site = SN ( author = lambda : config . author , bibliography = lambda : bib_to_html ( config ), builddate = lambda : now , copyrightyear = lambda : config . copyrightyear , domain = lambda : config . domain , email = lambda : config . email , glossary = lambda : gloss_to_html ( config , seen ), links = lambda : _links ( config ), repo = lambda : config . repo , title = lambda : config . title , subtitle = lambda : subtitle , tool = lambda : config . tool ) if \"foot.html\" in config . template : site . foot = lambda root : _fill ( \"foot.html\" , config . template [ \"foot.html\" ], site , SN ( root = root ) ) else : site . foot = lambda root : \"\" if \"head.html\" in config . template : site . head = lambda root : _fill ( \"head.html\" , config . template [ \"head.html\" ], site , SN ( root = root ) ) else : site . head = lambda root : \"\" if \"stats.html\" in config . template : filled = _fill ( \"stats.html\" , config . template [ \"stats.html\" ], site , SN ()) site . stats = lambda : filled else : site . stats = lambda : \"\" return site","title":"Template Expansion"},{"location":"template/#template","text":"Evaluate page templates to fill in content.","title":"Template"},{"location":"template/#mccole.template.fill_template","text":"Fill in page template if present. Source code in mccole/template.py def fill_template ( config , xref , info , site , html ): \"\"\"Fill in page template if present.\"\"\" template_name = info . metadata . get ( \"template\" , None ) if template_name is None : template_name = info . template if template_name is None : LOGGER . error ( f \"No template in { info . src } .\" ) return html template = config . template . get ( template_name , None ) if template is None : LOGGER . error ( f \"Unknown template { template_name } in { info . src } .\" ) return html LOGGER . debug ( f \"filling { template_name } for { info . src } \" ) site . toc = lambda : _site_toc ( config , xref ) page = SN ( content = lambda : html , keyterms = lambda : _keyterms ( config , info ), lede = lambda : _lede ( config , info ), title = lambda : f '<h1 id=\" { info . slug } \"> { info . title } </h1>' , to_root = lambda : info . to_root , toc = lambda : _page_toc ( info , xref ) ) return _fill ( template_name , template , site , page )","title":"fill_template()"},{"location":"template/#mccole.template.load_templates","text":"Load page templates. Source code in mccole/template.py def load_templates ( config ): \"\"\"Load page templates.\"\"\" config . template = {} for filename in glob ( f \" { TEMPLATE_DIR } /*.html\" ): label = os . path . basename ( filename ) with open ( filename , \"r\" ) as reader : text = reader . read () if \"'''\" in text : LOGGER . warning ( f \"Template { filename } contains triple quote '''.\" ) config . template [ label ] = text","title":"load_templates()"},{"location":"template/#mccole.template.make_site_object","text":"Make object with site values for evaluation. Source code in mccole/template.py def make_site_object ( config , seen ): \"\"\"Make object with site values for evaluation.\"\"\" now = datetime . today () . strftime ( \"%Y-%m- %d \" ) subtitle = ( f '<h2 class=\"subtitle\"> { config . subtitle } </h2>' if config . subtitle else \"\" ) site = SN ( author = lambda : config . author , bibliography = lambda : bib_to_html ( config ), builddate = lambda : now , copyrightyear = lambda : config . copyrightyear , domain = lambda : config . domain , email = lambda : config . email , glossary = lambda : gloss_to_html ( config , seen ), links = lambda : _links ( config ), repo = lambda : config . repo , title = lambda : config . title , subtitle = lambda : subtitle , tool = lambda : config . tool ) if \"foot.html\" in config . template : site . foot = lambda root : _fill ( \"foot.html\" , config . template [ \"foot.html\" ], site , SN ( root = root ) ) else : site . foot = lambda root : \"\" if \"head.html\" in config . template : site . head = lambda root : _fill ( \"head.html\" , config . template [ \"head.html\" ], site , SN ( root = root ) ) else : site . head = lambda root : \"\" if \"stats.html\" in config . template : filled = _fill ( \"stats.html\" , config . template [ \"stats.html\" ], site , SN ()) site . stats = lambda : filled else : site . stats = lambda : \"\" return site","title":"make_site_object()"},{"location":"tokenize/","text":"Tokenize Markdown Files Turn chapters into tokens. tokenize ( config ) Parse each file in turn. Source code in mccole/tokenize.py def tokenize ( config ): \"\"\"Parse each file in turn.\"\"\" md = make_md () links_table = _make_markdown_links ( config ) for info in config . pages : with open ( info . src , \"r\" ) as reader : text = reader . read () text += links_table info . tokens = md . parse ( text ) info . metadata = _get_metadata ( info . tokens ) info . keyterms = _get_keyterms ( info . tokens )","title":"Tokenize Markdown"},{"location":"tokenize/#tokenize-markdown-files","text":"Turn chapters into tokens.","title":"Tokenize Markdown Files"},{"location":"tokenize/#mccole.tokenize.tokenize","text":"Parse each file in turn. Source code in mccole/tokenize.py def tokenize ( config ): \"\"\"Parse each file in turn.\"\"\" md = make_md () links_table = _make_markdown_links ( config ) for info in config . pages : with open ( info . src , \"r\" ) as reader : text = reader . read () text += links_table info . tokens = md . parse ( text ) info . metadata = _get_metadata ( info . tokens ) info . keyterms = _get_keyterms ( info . tokens )","title":"tokenize()"},{"location":"util/","text":"Utility Functions Utilities. McColeExc ( Exception ) Problems we expect. Source code in mccole/util.py class McColeExc ( Exception ): \"\"\"Problems we expect.\"\"\" def __init__ ( self , msg ): \"\"\"Save the message.\"\"\" self . msg = msg __init__ ( self , msg ) special Save the message. Source code in mccole/util.py def __init__ ( self , msg ): \"\"\"Save the message.\"\"\" self . msg = msg err ( msg , info , token = None ) Report an error with location information. Source code in mccole/util.py def err ( msg , info , token = None ): \"\"\"Report an error with location information.\"\"\" LOGGER . error ( f \" { msg } { loc ( info , token ) } \" ) loc ( info , token ) Report error location in token stream. Source code in mccole/util.py def loc ( info , token ): \"\"\"Report error location in token stream.\"\"\" if token . map is None : return f \"( { info . src } )\" return f \"( { info . src } / { token . map [ 1 ] } )\" make_inclusion_filename ( info , name ) Construct full path name. Source code in mccole/util.py def make_inclusion_filename ( info , name ): \"\"\"Construct full path name.\"\"\" return os . path . join ( os . path . dirname ( info . src ), name ) make_md () Make Markdown parser. Source code in mccole/util.py def make_md (): \"\"\"Make Markdown parser.\"\"\" return ( MarkdownIt ( \"commonmark\" ) . enable ( \"table\" ) . use ( deflist_plugin ) . use ( front_matter_plugin ) )","title":"Utilities"},{"location":"util/#utility-functions","text":"Utilities.","title":"Utility Functions"},{"location":"util/#mccole.util.McColeExc","text":"Problems we expect. Source code in mccole/util.py class McColeExc ( Exception ): \"\"\"Problems we expect.\"\"\" def __init__ ( self , msg ): \"\"\"Save the message.\"\"\" self . msg = msg","title":"McColeExc"},{"location":"util/#mccole.util.McColeExc.__init__","text":"Save the message. Source code in mccole/util.py def __init__ ( self , msg ): \"\"\"Save the message.\"\"\" self . msg = msg","title":"__init__()"},{"location":"util/#mccole.util.err","text":"Report an error with location information. Source code in mccole/util.py def err ( msg , info , token = None ): \"\"\"Report an error with location information.\"\"\" LOGGER . error ( f \" { msg } { loc ( info , token ) } \" )","title":"err()"},{"location":"util/#mccole.util.loc","text":"Report error location in token stream. Source code in mccole/util.py def loc ( info , token ): \"\"\"Report error location in token stream.\"\"\" if token . map is None : return f \"( { info . src } )\" return f \"( { info . src } / { token . map [ 1 ] } )\"","title":"loc()"},{"location":"util/#mccole.util.make_inclusion_filename","text":"Construct full path name. Source code in mccole/util.py def make_inclusion_filename ( info , name ): \"\"\"Construct full path name.\"\"\" return os . path . join ( os . path . dirname ( info . src ), name )","title":"make_inclusion_filename()"},{"location":"util/#mccole.util.make_md","text":"Make Markdown parser. Source code in mccole/util.py def make_md (): \"\"\"Make Markdown parser.\"\"\" return ( MarkdownIt ( \"commonmark\" ) . enable ( \"table\" ) . use ( deflist_plugin ) . use ( front_matter_plugin ) )","title":"make_md()"},{"location":"write/","text":"Writing Files Write outputs. copy_files ( config ) Copy static files. Source code in mccole/write.py def copy_files ( config ): \"\"\"Copy static files.\"\"\" for pattern in config . copy : filenames = glob ( os . path . join ( config . src , pattern )) filenames = [ f for f in filenames if not any ( fnmatch ( f , p ) for p in config . exclude ) ] filenames = [ _pair_src_dst ( config , f ) for f in filenames ] for ( src_path , dst_path ) in filenames : LOGGER . info ( f \"copying { src_path } to { dst_path } \" ) _copy_file ( src_path , dst_path ) generate_pages ( config , xref , write = True ) Generate output for each chapter in turn, filling in cross-references. Source code in mccole/write.py def generate_pages ( config , xref , write = True ): \"\"\"Generate output for each chapter in turn, filling in cross-references.\"\"\" seen = Seen () site = make_site_object ( config , seen ) for info in config . pages : html = render ( config , xref , seen , info ) info . html = fill_template ( config , xref , info , site , html ) if write : _write_file ( info . dst , info . html ) return seen","title":"Writing Files"},{"location":"write/#writing-files","text":"Write outputs.","title":"Writing Files"},{"location":"write/#mccole.write.copy_files","text":"Copy static files. Source code in mccole/write.py def copy_files ( config ): \"\"\"Copy static files.\"\"\" for pattern in config . copy : filenames = glob ( os . path . join ( config . src , pattern )) filenames = [ f for f in filenames if not any ( fnmatch ( f , p ) for p in config . exclude ) ] filenames = [ _pair_src_dst ( config , f ) for f in filenames ] for ( src_path , dst_path ) in filenames : LOGGER . info ( f \"copying { src_path } to { dst_path } \" ) _copy_file ( src_path , dst_path )","title":"copy_files()"},{"location":"write/#mccole.write.generate_pages","text":"Generate output for each chapter in turn, filling in cross-references. Source code in mccole/write.py def generate_pages ( config , xref , write = True ): \"\"\"Generate output for each chapter in turn, filling in cross-references.\"\"\" seen = Seen () site = make_site_object ( config , seen ) for info in config . pages : html = render ( config , xref , seen , info ) info . html = fill_template ( config , xref , info , site , html ) if write : _write_file ( info . dst , info . html ) return seen","title":"generate_pages()"}]}