<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
<script defer data-domain="buildtogether.tech" src="https://plausible.io/js/plausible.js"></script>
<link rel="icon" type="image/x-icon" href="../files/favicon.ico">
<link rel="stylesheet" href="../mccole.css">
<link rel="stylesheet" href="../codehilite-tango.css">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
})
</script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    <title>Software Engineering: A Compassionate, Evidence-Based Approach / Reproducible Workflows</title>
  </head>
  <body class="page">
    <div align="center">
      
      <h2><a href="../">Software Engineering: A Compassionate, Evidence-Based Approach</a></h2>
      <h1>: Reproducible Workflows</h1>
      
      <p>
        <img class="page-logo" src="../codebender.svg" alt="logo" />
      </p>
    </div>

<p>It's easy to run one program to process a single data file,
but what happens when our analysis depends on many files,
or when we need to re-do the analysis every time new data arrives?
What should we do if the analysis has several steps
that we have to do in a particular order?</p>
<p>If we try to keep track of this ourselves,
we will inevitably forget some crucial steps,
and it will be hard for other people to pick up our work.
Instead,
we should use a <span g="build_tool">build tool</span>
to keep track of what depends on what
and run our analysis programs automatically.
These tools were invented to help programmers rebuild complex software,
but can be used to automate any workflow.</p>
<div class="callout">
<h3>Make</h3>
<p>The first widely-used build tool, Make, written in 1976.  Programmers have
created many replacements for it in the decades since thenâ€”so many, in fact,
that none have attracted enough users to displace it entirely.</p>
</div>
<p>When Snakemake runs,
it reads <span g="build_rule">build rules</span> from a file called <code>Snakefile</code>.
(It can be called other things, but that's the convention.)
Each rule explains how to update a <span g="build_target">target</span>
if it is out of date compared to any of its <span g="build_prerequisite">prerequisites</span>.
Here's a rule to regenerate a compressed data file <code>data/all-versions.csv.gz</code>
if the file is older than the script used to create it:</p>
<div class="codehilite"><pre><span></span><code><span class="n">rule</span> <span class="n">all_versions</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;Download all version info from PyPI - takes several hours.&#39;&#39;&#39;</span>
    <span class="n">output</span><span class="p">:</span>
        <span class="n">protected</span><span class="p">(</span><span class="s1">&#39;data/all-versions.csv.gz&#39;</span><span class="p">)</span>
    <span class="n">shell</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        python bin/get-all-versions.py &gt; data/all-versions.csv</span>
<span class="sd">        gzip data/all-versions.csv</span>
<span class="sd">        &#39;&#39;&#39;</span>
</code></pre></div>

<ul>
<li>First line gives the rule a meaningful name</li>
<li>Second is a docstring<ul>
<li><code>snakemake --list</code> will show the rules and their docstrings</li>
</ul>
</li>
<li><code>output</code> section tells Snakemake what file(s) this rule produces<ul>
<li>The <code>protected</code> function tells Snakemake to change permissions on the file so it won't accidentally be deleted</li>
<li>Only do this for files that take a long time to re-create</li>
</ul>
</li>
<li><code>shell</code> section tells Snakemake what command(s) to run to create the output<ul>
<li>It will automatically create the <code>data</code> directory if need be</li>
<li>We can put Python directly in the Snakefile, but I prefer scripts so that commands can be re-run independently</li>
</ul>
</li>
</ul>
<div class="callout">
<h3>Compressing Data</h3>
<p>Compressing this dataset takes file from 103.8 Mbyte to 9.5 Mbyte, which is
almost a factor of 11.  However, version control can only diff and merge plain
text files, so if the file is compressed, Git can't help us track changes to
individual lines.  On the other hand we probably shouldn't be changing a dataset
anyway...</p>
</div>
<ul>
<li>Execute these commands with</li>
</ul>
<div class="codehilite"><pre><span></span><code>snakemake -j <span class="m">1</span> all_versions
</code></pre></div>

<p>Since that will take several hours to complete,
let's add another rule to the same file:</p>
<div class="codehilite"><pre><span></span><code><span class="n">rule</span> <span class="n">releases_per_package</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;How many releases are there for each package?&#39;&#39;&#39;</span>
    <span class="nb">input</span><span class="p">:</span>
        <span class="s1">&#39;data/all-versions.csv.gz&#39;</span>
    <span class="n">output</span><span class="p">:</span>
        <span class="s1">&#39;results/releases.csv&#39;</span>
    <span class="n">shell</span><span class="p">:</span>
        <span class="s1">&#39;python bin/count-releases.py </span><span class="si">{input}</span><span class="s1"> &gt; </span><span class="si">{output}</span><span class="s1">&#39;</span>
</code></pre></div>

<ul>
<li><code>-j1</code> means "only run one job at a time"<ul>
<li>Snakemake can run many jobs in parallel</li>
</ul>
</li>
<li><code>results/releases.csv</code> depends on an input data file</li>
<li>Snakemake only runs the commands if the output doesn't exist or is older than the input</li>
</ul>
<p><code>count-releases.py</code> is only a few lines long.
It takes advantage of the fact that if we give Pandas' <code>read_csv</code> function
a string instead of a stream
it assumes that parameter is a filename,
and that it can read directly from compressed files
(which it identifies by looking for common endings like <code>.zip</code> or <code>.gz</code>).</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># !/usr/bin/env python</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Count how many releases there are per package.</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Main driver.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;Package&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Release</span><span class="o">.</span><span class="n">nunique</span><span class="p">()</span>
    <span class="n">result</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</code></pre></div>

<p>{: title="bin/count-releases.py"}</p>
<p>If we run:</p>
<div class="codehilite"><pre><span></span><code>snakemake -j1 releases_per_package
</code></pre></div>

<p>and wait a few seconds,
we have a file with the following:</p>
<div class="codehilite"><pre><span></span><code>Package,Release
0,1
0-0-1,1
0-core-client,9
0-orchestrator,14
00print-lol,2
01d61084-d29e-11e9-96d1-7c5cf84ffe8e,2
021,1
...
</code></pre></div>

<p>Creating a Snakefile may seem like extra work,
but few things in life are as satisfying as running one command
and watching an entire multi-step analysis run itself:</p>
<ol>
<li>
<p>It reduces errors,
    since we only have to type commands correctly once
    instead of over and over again.</p>
</li>
<li>
<p>More importantly,
    it documents our workflow
    so that someone else (including our future self)
    can see exactly what steps we used in what order.</p>
</li>
</ol>
<h2>How can we remove redundant releases?</h2>
<ul>
<li>How many packages are released in redundant formats (e.g., as both <code>.tar.gz</code> and <code>.whl</code>)?</li>
<li>First step is to find out what formats are represented in the data<ul>
<li>Break names on <code>.</code></li>
<li>Count how often each type of field appears</li>
</ul>
</li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="c1"># !/usr/bin/env python</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Count frequency of &#39;.&#39;-separated components of names.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;Release&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">del</span> <span class="n">data</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;index&#39;</span><span class="p">:</span> <span class="s1">&#39;Component&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;Count&#39;</span><span class="p">})</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="o">~</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;Component&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^\d+$&#39;</span><span class="p">,</span> <span class="n">na</span><span class="o">=</span><span class="kc">False</span><span class="p">)]</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s1">&#39;Count&#39;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">data</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</code></pre></div>

<p>{: title="bin/components.py"}</p>
<ul>
<li>
<p>In order:</p>
<ul>
<li>Read the file</li>
<li>Split the <code>Release</code> column on <code>.</code>, creating new columns for the fragments</li>
<li>Flatten all those columns into a single vector</li>
<li>Count how often each component appears</li>
<li>Remove the <code>None</code> value (because splitting on <code>.</code> created a lot of blanks)</li>
<li>Turn the result back into a dataframe and reset the index<ul>
<li>We explore why we need to reset the index in the exercises</li>
</ul>
</li>
<li>Give the columns sensible names</li>
<li>Keep values that aren't composed entirely of digits (after inspection)</li>
<li>Sort by count</li>
<li>Save</li>
</ul>
</li>
<li>
<p>We did <em>not</em> write this all at once</p>
<ul>
<li>Write the first couple of steps</li>
<li><code>gunzip -c data/all-versions.csv | head -n 10 &gt; /tmp/test-data.csv.gz</code> to create a test dataset</li>
<li>Keep adding steps</li>
<li>Enlarge the test set once the pipeline seems to be working</li>
</ul>
</li>
<li>
<p>Add a rule to <code>Snakefile</code></p>
</li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="nf">rule count_name_components</span><span class="o">:</span>
    <span class="s1">&#39;&#39;&#39;How often does each component of a dotted name occur?&#39;&#39;&#39;</span>
    input:
        <span class="s1">&#39;data/all-versions.csv.gz&#39;</span>
    output:
        <span class="s1">&#39;results/name-component-count.csv&#39;</span>
    shell:
        <span class="s1">&#39;python bin/components.py {input} &gt; {output}&#39;</span>
</code></pre></div>

<ul>
<li>Run</li>
</ul>
<div class="codehilite"><pre><span></span><code>Component,Count
tar,1298365
gz,1294773
whl,833181
py3-none-any,219230
egg,83174
zip,79232
0-py2,56429
0-py3-none-any,53955
1-py3-none-any,46384
1-py2,42507
2-py3-none-any,29974
2-py2,27282
3-py3-none-any,21383
3-py2,19175
exe,17161
0-py2-none-any,16079
4-py3-none-any,15782
4-py2,14105
5-py3-none-any,12791
1-py2-none-any,11683
5-py2,11233
...
</code></pre></div>

<ul>
<li>
<p>Most common suffixes are <code>.tar.gz</code>, <code>.tar</code>, <code>.whl</code>, <code>.egg</code>, <code>.zip</code>, and <code>.exe</code></p>
<ul>
<li>Need domain knowledge to recognize these</li>
<li>And to know that <code>.tar</code> and <code>.gz</code> appear together</li>
</ul>
</li>
<li>
<p>Add this rule at the top of the file</p>
<ul>
<li>Depends on two files but doesn't have an action</li>
<li>Snakemake re-creates both files</li>
</ul>
</li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="n">rule</span> <span class="nb">all</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;Dummy rule to rebuild everything.&#39;&#39;&#39;</span>
    <span class="nb">input</span><span class="p">:</span>
        <span class="p">[</span><span class="s1">&#39;results/releases.csv&#39;</span><span class="p">,</span> <span class="s1">&#39;results/name-component-count.csv&#39;</span><span class="p">]</span>
</code></pre></div>

<ul>
<li>Next, calculate how many releases there are per package once we remove duplicates</li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Count releases before and after de-duplication.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">num_packages</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">Stripped</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;Release&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\.(tar\.gz|tar|whl|egg|zip|exe)$&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">))</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;Complete&#39;</span><span class="p">:</span> <span class="n">data</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;Package&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Release</span><span class="o">.</span><span class="n">nunique</span><span class="p">(),</span>
                           <span class="s1">&#39;Stripped&#39;</span><span class="p">:</span> <span class="n">data</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;Package&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Stripped</span><span class="o">.</span><span class="n">nunique</span><span class="p">()})</span>
    <span class="n">num_shorter</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">result</span><span class="o">.</span><span class="n">Complete</span> <span class="o">&gt;</span> <span class="n">result</span><span class="o">.</span><span class="n">Stripped</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">num_shorter</span><span class="si">}</span><span class="s1"> / </span><span class="si">{</span><span class="n">num_packages</span><span class="si">}</span><span class="s1"> (</span><span class="si">{</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="n">num_shorter</span> <span class="o">/</span> <span class="n">num_packages</span><span class="p">)</span><span class="si">:</span><span class="s1">6.2</span><span class="si">}</span><span class="s1">%) shorter&#39;</span><span class="p">)</span>
</code></pre></div>

<p>{: title="bin/remove-duplicates.py"}</p>
<ul>
<li>Rule in Snakefile doesn't produce an output file<ul>
<li>Just shows us</li>
</ul>
</li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="n">rule</span> <span class="n">count_redundant_releases</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;How many duplicated (redundant) releases are there?&#39;&#39;&#39;</span>
    <span class="nb">input</span><span class="p">:</span>
        <span class="s1">&#39;data/all-versions.csv.gz&#39;</span>
    <span class="n">shell</span><span class="p">:</span>
        <span class="s1">&#39;python bin/remove-duplicates.py data/all-versions.csv.gz&#39;</span>
</code></pre></div>

<ul>
<li>Output</li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="mf">2255</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">2312545</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="mf">0.098</span><span class="err">%</span><span class="p">)</span><span class="w"> </span><span class="n">shorter</span><span class="w"></span>
</code></pre></div>

<ul>
<li>So this <em>isn't</em> a big enough issue to explain the even-numbered jagginess of our earlier figure</li>
</ul>
<h2>Exercises</h2>
<h3>Compressing Results</h3>
<p>We decided to compress the source data file used in this chapter.
Should we compress the results file(s) we generate as well?
Why or why not?</p>

  <hr/>
<div class="centered">
  <table class="plain footer">
    <tr>
      
      <td><a href="../license/">License</a></td>
      
      <td><a href="../conduct/">Code of Conduct</a></td>
      
      <td><a href="../bibliography/">Bibliography</a></td>
      
      <td><a href="../glossary/">Glossary</a></td>
      
      <td><a href="../links/">Links</a></td>
      
      <td><a href="https://github.com/gvwilson/seceba">GitHub</a></td>
      
    </tr>
  </table>
</div>

  </body>
</html>
