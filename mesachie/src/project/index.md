---
title: "A Minimum Viable Project"
---

-   Some things are the same for every project [% b Fogel2005, Fogel2020 %]
-   Show the Python version with some notes about JavaScript

## Create repository on GitHub

-   Do this under a personal account, but for a real project would do it under an organizational account
-    Chose a name that wasn't already taken on [PyPI][pypi]
    -   Because we want to create a package in future
    -   All the good names are taken, so I chose the name of a small town near where I grew up
-   Made it public
-   Added the following:
    -   `README.md` (this file) is normally a description of the project, but we'll use it for note-taking
    -   `.gitignore` (selected from pulldown) to tell Git not to track ephemeral files generated by Python projects
    -   [MIT license][mit-license] (which GitHub puts in `LICENSE` rather than `LICENSE.md` - rename it)

## Add the files every project should have

-   Write these notes
-   Rename `LICENSE` to `LICENSE.md` (because file extensions are good)
-   Add `*~` to the `.gitignore` (for Emacs users)
-   Commit changes with a message that follows [conventional commits][conventional-commits]:

```
feat: describing steps so far and cleaning up default files

-   Rename `LICENSE` to show it's a Markdown file
-   Add notes to `README.md` about steps so far
-   Add Emacs backup files to `.gitignore
```

-   The subject line describes what kind of change it is (adding a feature)
    -   The body itemizes the changes
-   Push to GitHub

## Add Code of Conduct and contributors' guide

-   Used to add CoC by copying in a Markdown file, but [GitHub now supports this directly][gh-coc]
    -   Note: use `[text][key]` links in the body of my Markdown files and `[key]: url` in the foot
-   Follow GitHub's instructions to add CoC
    -   Call the branch `feat/code-of-conduct` (colons don't play nicely in Git branch names)
-   Copy in `CONTRIBUTING.md` from an existing project and edit
    -   Rename/add tags in GitHub to match descriptions in `CONTRIBUTING.md` (because GitHub's defaults aren't sensible)
-   *Don't* add a `GOVERNANCE.md` file explaining how decisions are made and who gets to make them
    -   But will as soon as the project attracts other people
-   Note: if you and your team are creating a lot of projects, consider using [Cookiecutter][cookiecutter] to keep them consistent

## Set up Python package

-   Create `mesachie` directory to contain package code
    -   Standard Python package structure to keep package code separate from support code
-   Add `mesachie/__init__.py`:

```python
"""Mesachie: a data analysis software project in Python."""

__version__ = "0.1.0"
__author__ = "Greg Wilson"
```

-   The existence of `__init__.py` signals that this directory is an importable module
        -   It can even be empty
    -   First line is a documentation string (docstring) explaining the file's purpose
    -   The `__version__` and `__author__` variables are recognized by Python's packaging tools
-   Create `tests` directory *beside* the `mesachie` package directory to contain tests
    -   And create `tests/__init__.py` to keep testing tools happy

```python
"""Make tests look like a module so actual module will load."""
```

-   Create a [conda][conda] virtual environment to avoid conflicts between packages installed for different projects
    -   Note: some people prefer [Docker][docker] for isolating environments...
    -   ...and because it's what we'll eventually use when we run in the cloud

```bash
$ conda create -n mesachie python=3.9
# say 'y' to the prompt
$ conda activate mesachie
```

-   Install [pytest][pytest] to run tests:
    -   Can (should) use `conda install` instead, but `pip` is simpler for small projects

```bash
$ pip install pytest
```

-   Create `requirements.txt` to make package installation reproducible
    -   What version did we get?

```bash
$ conda list pytest
#> pytest        7.1.1
```

-   Name uses three-part [semantic versioning][semver] to identify major version, minor version, and patch
-   Create `requirements.txt` file with major and minor version

```
pytest>=7.1
```

-   Create a "heartbeat" test in `tests/test_heartbeat.py` to make sure we can load our module

```python
"""Check that the project has a heartbeat."""

import mesachie


def test_module_can_be_imported():
    pass
```

-   Names of test files and functions must started with `test_` so that `pytest` can find them
    -   Don't use docstrings for tests: give them long informative names
    -   This test doesn't check anything (`pass`), but `pytest` will complain if `mesachie` cannot be imported
-   Run the test:

```bash
$ pytest
#> collected 1 item
#> tests/test_heartbeat.py .  
```

-   Add to these notes, commit, and push

## Automation

-   Want to make common commands re-runnable
    -   More trustworthy than documentation
-   Used to use [Make][make] to do this, but it's showing its age
    -   And its syntax is unpleasant
-   Use [Invoke][invoke] instead
-   `pip install invoke` and then add `invoke>=1.7` to `requirements.txt
-   Create a file in the project's root directory called `tasks.py`:

```python
"""Run common tasks."""

from invoke import task


@task
def list(c):
    """List available tasks."""
    c.run("inv --list")


@task
def test(c):
    """Run tests."""
    c.run("pytest")
```

-   The `@task` decorator identifies functions that can be run as tasks
    -   They can do any other processing (but we don't need them to yet)
-   The `c` parameter is a context that has details about the run
    -   We don't need that yet either
-   Run `inv list`:

```
Available tasks:

  list   List available tasks
  test   Run tests
```

-   We need to set up a [% g linter "linter" %] to check code quality
-   And [% g ci "continuous integration" %] to make sure it runs
-   But we need some useful code first

## Linting

-   [PEP 8][pep8] lays out some guidelines for readable Python, but checking those rules is tedious
-   [Black][black], [Flake8][flake8], and [isort][isort] check most of the rules for you
    -   And can reformat code to obey them
-   `pip install black flake8 isort` and then add entries to `requirements.txt`
-   `black --check .` will check all the Python code in or below the current directory
-   `black .` will reformat anything that doesn't conform to style guidelines
-   `flake8` only checks for flaky code
-   `isort` can both check and reformat (order and format of `import` statements)
-   So add two tasks to `tasks.py`:
    -   The term "lint" comes from an early tool for C that reported questionable code

```python
@task
def lint(c):
    """Run checks on code."""
    c.run("flake8", warn=True)
    c.run("isort --check .")
    c.run("black --check .")


@task
def reformat(c):
    """Reformat code."""
    c.run("isort .")
    c.run("black .")
```

-   Change the test to actually test something

```python
def test_module_can_be_imported():
    assert hasattr(mesachie, "__author__")
    assert hasattr(mesachie, "__version__")
```

## Continuous Integration

-   Should always run checks when committing code
    -   Or changing documentation, or...
-   But human beings are fallible, so automate: continuous integration (CI)
-   Many dedicated CI services like [Circle CI][circle-ci]
-   For a project this size, easiest is [GitHub Actions][gh-actions]
-   Create a directory `.github/workflows` beneath the root of the project
-   Add a file `test-on-push.yml` in that directory:

```yaml
name: Test on Push
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Python
        uses: actions/setup-python@v1
        with:
          python-version: 3.9
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      - name: Run code checks
        run: inv lint
      - name: Run tests
        run: inv test
        if: ${{ always() }}
```

-   `name` is the name of the action (used in error reporting, etc.)
-   `on` defines when the action runs
    -   When there's a `push` to the `main` branch
    -   When anyone creates a pull request whose target is `main`
    -   Lots of other options
-   `jobs` defines what to do when the action runs
    -   An action can run many jobs in parallel
-   We want to build our software on the latest version of Ubuntu Linux
    -   Probably the most common platform
-   Spell out the steps:
    -   Use a [pre-defined `checkout` action][gh-actions-predefined] to get a fresh copy of the repo
    -   Set up Python using another pre-defined action
    -   Install everything listed in `requirements.txt`
    -   Run the code checks (do *not* reformat, just check)
    -   Run the tests: the `if` condition means "even if the previous linting step fails"
-   Before we test it, let's split requirements into "needed for install" and "also used in dev"
-   `requirements.txt` becomes:

```
kaleido>=0.2
pandas>=1.4
plotly>=5.6
pydantic>=1.9.0
pyyaml>=5.4
requests>=2.27
statsmodels>=0.13
```

-   Create a new file `development.txt` that tells `pip` to read `requirements.txt` (using `-r`) then add more packages

```
-r requirements.txt
black>=22.1
coverage>=6.3
flake8>=4.0
invoke>=1.7
isort>=5.10
ivy>=6.2
pdoc3>=0.10
pymdown-extensions>=9.3
pyproject-flake8
pytest>=7.1
```

-   `git add` changes, commit, push to GitHub, go to the `Actions` tab: the job has failed
    -   Because `invoke` isn't included in `requirements.txt`, but is needed for the action
    -   So are `black`, `flake8`, `isort`, and `pytest`
-   Move `invoke` to `requirements.txt`, add, commit, push
    -   Works this time
    -   Some projects have `development.txt`, `testing.txt`, and `requirements.txt` for this reason
    -   It all should live in `pyproject.toml`...

<div class="callout" markdown="1">
### Other Jobs

The GitHub Actions tab shows all the jobs, including the ones that build and deploy the website.
If you have pushed several times, then rebase and push the combined commit,
the jobs run by the now-squashed commits still show up.
</div>
